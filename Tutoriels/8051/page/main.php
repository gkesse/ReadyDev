<div class="Parallax GParallax1"><div class="Img Binary"><div class="Caption"><a href="#"><div class="Text">Apprendre le développement de système embarqué en C avec le 8051</div></a></div></div><div class="Body2 Orange">Le <b>8051</b> est un microcontrôleur de développement de système embarqué.<br>Le but de ce tutoriel est de vous apprendre le développement de système embarqué en C avec le <b>8051</b>.<br>Produit par <b>Gérard KESSE</b>.<br><br><div class="Content0 GSummary1"><div class="Body0" id="Loader_1529412976174"><div class="Row26">Summary 1</div></div><script>loadSummary1("Loader_1529412976174");</script></div></div></div><br><div class="Content2 GTitle1"><div class="MainBlock2"><div class="Content"><h1 class="Title2 Center" id="Installation sous Windows"><a class="Link3" href="#">Installation sous Windows</a></h1><div class="Body3">Le but de cette section est de vous présenter les différents outils nécessaires pour apprendre le développement de système embarqué avec le <span class="GColor1" style="color:lime;">8051</span><span class="GColor1" style="color:lime;"></span>, sous Windows.<br>Produit par <b>Gérard KESSE</b>.<br><br>Dans ce tutoriel, nous utiliserons, sous Windows:<br>- Keil µVision, comme environnement de développement intégré.<br>- Proteus, comme simulateur de circuits électriques.<br>- VSPE, comme émulateur de ports série.<br>- RealTerm, comme terminal de communications série.<br>- Notepad++, comme éditeur de texte.<br><br><h3 class="Title8 GTitle3">Télécharger Keil µVision<br></h3><a class="Link7 GLink1" style="color:lime;" target="_blank" href="https://www.keil.com/">https://www.keil.com/</a><br><br><h3 class="Title8 GTitle3">Télécharger Proteus</h3><a class="Link7 GLink1" style="color:lime;" target="_blank" href="https://www.labcenter.com/">https://www.labcenter.com/</a><br><br><h3 class="Title8 GTitle3">Télécharger VSPE</h3><a class="Link7 GLink1" style="color:lime;" target="_blank" href="http://www.eterlogic.com/Downloads.html">http://www.eterlogic.com/Downloads.html</a><br><br><h3 class="Title8 GTitle3">Télécharger RealTerm</h3><a class="Link7 GLink1" style="color:lime;" target="_blank" href="https://sourceforge.net/projects/realterm/">https://sourceforge.net/projects/realterm/</a><br><br><h3 class="Title8 GTitle3">Télécharger Notepad++</h3><a class="Link7 GLink1" style="color:lime;" target="_blank" href="https://notepad-plus-plus.org/fr/">https://notepad-plus-plus.org/fr/</a></div></div></div></div><br><div class="Content2 GTitle1"><div class="MainBlock2"><div class="Content"><h1 class="Title2 Center" id="Utilisation de Keil µVision"><a class="Link3" href="#">Utilisation de Keil µVision</a></h1><div class="Body3">Le but de cette section est de vous apprendre à utiliser <span class="GColor1" style="color:lime;">Keil µVision</span>, sous Windows.<br>Produit par <b>Gérard KESSE</b>.<br><br>Keil µVision permet d'éditer des programmes, les compiler et les charger dans les microcontrôleurs 8051.<br><br><div class="Content0 GSummary2"><div class="Body0" id="Loader_1532274847335"><div class="Row26">Summary 2</div></div><script>loadSummary2("Loader_1532274847335");</script></div><br><h2 class="Title7 GTitle2" id="Utilisation de Keil µVision-Créer des nouveaux projets"><a class="Link9" href="#Utilisation de Keil µVision">Créer des nouveaux projets</a></h2><br><h3 class="Title8 GTitle3">Créer des nouveaux projets</h3><div class="Img3 GImage"><img src="img/Keil.png" alt="img/Keil.png"></div><br><div class="Img3 GImage"><img src="img/Keil_02.png" alt="img/Keil_02.png"></div><br><div class="Img3 GImage"><img src="img/Keil_03.png" alt="img/Keil_03.png"></div><br><div class="Img3 GImage"><img src="img/Keil_04.png" alt="img/Keil_04.png"></div><br><div class="Img3 GImage"><img src="img/Keil_05.png" alt="img/Keil_05.png"></div><br><h2 class="Title7 GTitle2" id="Utilisation de Keil µVision-Créer des fichiers sources"><a class="Link9" href="#Utilisation de Keil µVision">Créer des fichiers sources</a></h2><br><h3 class="Title8 GTitle3">Créer des fichiers sources</h3><div class="Img3 GImage"><img src="img/Keil_06.png" alt="img/Keil_06.png"></div><br><div class="Img3 GImage"><img src="img/Keil_07.png" alt="img/Keil_07.png"></div><br><div class="Img3 GImage"><img src="img/Keil_08.png" alt="img/Keil_08.png"></div><br><div class="Img3 GImage"><img src="img/Keil_09.png" alt="img/Keil_09.png"></div><br><div class="Img3 GImage"><img src="img/Keil_10.png" alt="img/Keil_10.png"></div><br><h2 class="Title7 GTitle2" id="Utilisation de Keil µVision-Créer des fichiers headers"><a class="Link9" href="#Utilisation de Keil µVision">Créer des fichiers headers</a></h2><br><h3 class="Title8 GTitle3">Créer des fichiers headers</h3><div class="Img3 GImage"><img src="img/Keil_17.png" alt="img/Keil_17.png"></div><br><div class="Img3 GImage"><img src="img/Keil_18.png" alt="img/Keil_18.png"></div><br><div class="Img3 GImage"><img src="img/Keil_19.png" alt="img/Keil_19.png"></div><br><div class="Img3 GImage"><img src="img/Keil_20.png" alt="img/Keil_20.png"></div><br><div class="Img3 GImage"><img src="img/Keil_21.png" alt="img/Keil_21.png"></div><br><h2 class="Title7 GTitle2" id="Utilisation de Keil µVision-Ajouter des fichiers sources"><a class="Link9" href="#Utilisation de Keil µVision">Ajouter des fichiers sources</a></h2><br><h3 class="Title8 GTitle3">Ajouter des fichiers sources</h3><div class="Img3 GImage"><img src="img/Keil_11.png" alt="img/Keil_11.png"></div><br><div class="Img3 GImage"><img src="img/Keil_12.png" alt="img/Keil_12.png"></div><br><div class="Img3 GImage"><img src="img/Keil_13.png" alt="img/Keil_13.png"></div><br><h2 class="Title7 GTitle2" id="Utilisation de Keil µVision-Configurer des répertoires de fichiers headers"><a class="Link9" href="#Utilisation de Keil µVision">Configurer des répertoires de fichiers headers</a></h2><br><h3 class="Title8 GTitle3">Configurer des répertoires de fichiers headers</h3><div class="Img3 GImage"><img src="img/Keil_22.png" alt="img/Keil_22.png"></div><br><div class="Img3 GImage"><img src="img/Keil_23.png" alt="img/Keil_23.png"></div><br><div class="Img3 GImage"><img src="img/Keil_24.png" alt="img/Keil_24.png"></div><br><div class="Img3 GImage"><img src="img/Keil_25.png" alt="img/Keil_25.png"></div><br><h2 class="Title7 GTitle2" id="Utilisation de Keil µVision-Créer des fichiers exécutables"><a class="Link9" href="#Utilisation de Keil µVision">Créer des fichiers exécutables</a></h2><br><h3 class="Title8 GTitle3">Créer des fichiers exécutables</h3><div class="Img3 GImage"><img src="img/Keil_14.png" alt="img/Keil_14.png"></div><br><div class="Img3 GImage"><img src="img/Keil_15.png" alt="img/Keil_15.png"></div><br><div class="Img3 GImage"><img src="img/Keil_16.png" alt="img/Keil_16.png"></div><br><h2 class="Title7 GTitle2" id="Utilisation de Keil µVision-Compiler des projets"><a class="Link9" href="#Utilisation de Keil µVision">Compiler des projets</a></h2><br><h3 class="Title8 GTitle3">Compiler des projets</h3><div class="Img3 GImage"><img src="img/Keil_26.png" alt="img/Keil_26.png"></div><br><div class="Img3 GImage"><img src="img/Keil_27.png" alt="img/Keil_27.png"></div><br><h2 class="Title7 GTitle2" id="Utilisation de Keil µVision-Définir des macros préprocesseurs"><a class="Link9" href="#Utilisation de Keil µVision">Définir des macros préprocesseurs</a></h2><br><h3 class="Title8 GTitle3">Définir des macros préprocesseurs</h3><div class="Img3 GImage"><img src="img/Keil_28.png" alt="img/Keil_28.png"></div><br><div class="Img3 GImage"><img src="img/Keil_29.png" alt="img/Keil_29.png"></div><br><h2 class="Title7 GTitle2" id="Utilisation de Keil µVision-Consulter la documentation"><a class="Link9" href="#Utilisation de Keil µVision">Consulter la documentation</a></h2><br><h3 class="Title8 GTitle3">Consulter la documentation</h3><div class="Img3 GImage"><img src="img/Keil_30.png" alt="img/Keil_30.png"></div><br><div class="Img3 GImage"><img src="img/Keil_31.png" alt="img/Keil_31.png"></div><br><div class="Img3 GImage"><img src="img/Keil_32.png" alt="img/Keil_32.png"></div><br><div class="Img3 GImage"><img src="img/Keil_33.png" alt="img/Keil_33.png"></div></div></div></div></div><br><div class="Content2 GTitle1"><div class="MainBlock2"><div class="Content"><h1 class="Title2 Center" id="Utilisation de Proteus"><a class="Link3" href="#">Utilisation de Proteus</a></h1><div class="Body3">Le but de cette section est de vous apprendre à utiliser <span class="GColor1" style="color:lime;">Proteus</span>, sous Windows.<br>Produit par <b>Gérard KESSE</b>.<br><br>Proteus permet de simuler des circuits électriques.<br><br><div class="Content0 GSummary2"><div class="Body0" id="Loader_1533796804798"><div class="Row26">Summary 2</div></div><script>loadSummary2("Loader_1533796804798");</script></div><br><h2 class="Title7 GTitle2" id="Utilisation de Proteus-Ajouter des composants"><a class="Link9" href="#Utilisation de Proteus">Ajouter des composants</a></h2><br><h3 class="Title8 GTitle3">Ajouter des composants</h3><div class="Img3 GImage"><img src="img/Proteus.png" alt="img/Proteus.png"></div><br><div class="Img3 GImage"><img src="img/Proteus_02.png" alt="img/Proteus_02.png"></div><br><div class="Img3 GImage"><img src="img/Proteus_03.png" alt="img/Proteus_03.png"></div><br><h2 class="Title7 GTitle2" id="Utilisation de Proteus-Créer des schémas électriques"><a class="Link9" href="#Utilisation de Proteus">Créer des schémas électriques</a></h2><br><h3 class="Title8 GTitle3">Créer des schémas électriques</h3><div class="Img3 GImage"><img src="img/Proteus_04.png" alt="img/Proteus_04.png"></div><br><h2 class="Title7 GTitle2" id="Utilisation de Proteus-Charger des fichiers exécutables"><a class="Link9" href="#Utilisation de Proteus">Charger des fichiers exécutables</a></h2><br><h3 class="Title8 GTitle3">Charger des fichiers exécutables</h3><div class="Img3 GImage"><img src="img/Proteus_07.png" alt="img/Proteus_07.png"></div><br><div class="Img3 GImage"><img src="img/Proteus_08.png" alt="img/Proteus_08.png"></div><br><h2 class="Title7 GTitle2" id="Utilisation de Proteus-Démarrer des simulations électriques"><a class="Link9" href="#Utilisation de Proteus">Démarrer des simulations électriques</a></h2><br><h3 class="Title8 GTitle3">Démarrer des simulations électriques</h3><div class="Img3 GImage"><img src="img/Proteus_05.png" alt="img/Proteus_05.png"></div><br><div class="Img3 GImage"><img src="img/Proteus_06.png" alt="img/Proteus_06.png"></div></div></div></div></div><br><div class="Content2 GTitle1"><div class="MainBlock2"><div class="Content"><h1 class="Title2 Center" id="Définir une structure boucle infinie"><a class="Link3" href="#">Définir une structure boucle infinie</a></h1><div class="Body3">Le but de cette section est de vous apprendre à <span class="GColor1" style="color:lime;">définir une structure boucle infinie</span> avec le C 8051.<br>Produit par <b>Gérard KESSE</b>.<br><br>La structure logicielle boucle infinie permet de gérer des applications embarquées monotâche.<br><br><h3 class="Title8 GTitle3">Structure logicielle boucle infinie</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void main() {
    GLedFlash_Init();
    while(1) {
        GLedFlash_Update();
    }
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Initialisation de la diode LED</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GLedFlash_Init() {
    LED_PIN = LED_OFF;
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Mise à jour de la diode LED</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GLedFlash_Update() {
    if(gLedFlash_State == FALSE) {
        gLedFlash_State = TRUE;
        LED_PIN = LED_ON;
    }
    else {
        gLedFlash_State = FALSE;
        LED_PIN = LED_OFF;
    }
    GDelay_ms(1000);
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Délai logiciel</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GDelay_ms(uint ms) {
    uint lDelay;
    uint lDelay_ms;
    for(lDelay = 0; lDelay < ms; lDelay++) {
        for(lDelay_ms = 0; lDelay_ms < DELAY_MS; lDelay_ms++);
    }
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Simulation électrique</h3><br><span class="GColor1" style="color:lime;">Diode LED éteinte pendant 1s</span><div class="Img3 GImage"><img src="img/Boucle_Infinie.png" alt="img/Boucle_Infinie.png"></div><br><span class="GColor1" style="color:lime;">Diode LED allumée pendant 1s</span><div class="Img3 GImage"><img src="img/Boucle_Infinie_02.png" alt="img/Boucle_Infinie_02.png"></div><br><span class="GColor1" style="color:lime;">Forme d'onde (Oscilloscope)</span><div class="Img3 GImage"><img src="img/Boucle_Infinie_03.png" alt="img/Boucle_Infinie_03.png"></div></div></div></div></div><br><div class="Content2 GTitle1"><div class="MainBlock2"><div class="Content"><h1 class="Title2 Center" id="Gérer le mode Idle"><a class="Link3" href="#">Gérer le mode Idle</a></h1><div class="Body3">Le but de cette section est de vous apprendre à <span class="GColor1" style="color:lime;">gérer le mode Idle</span> avec le C 8051.<br>Produit par <b>Gérard KESSE</b>.<br><br>Le mode Idle permet de passer en mode économie d'énergie.<br><br><h3 class="Title8 GTitle3">Programme principal</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void main() {
    GLedFlash_Init();
    GInterruptEx0_Init();
    while(1) {
        GLedFlash_Update();
        GModeIdle_Start();
    }
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Initialisation de la diode LED</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GLedFlash_Init() {
    LED_PIN = LED_OFF;
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Mise à jour de la diode LED</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GLedFlash_Update() {
    gLedFlash_Time = 0;
    while(1) {
        if(gLedFlash_State == FALSE) {
            gLedFlash_State = TRUE;
            LED_PIN = LED_ON;
        }
        else {
            gLedFlash_State = FALSE;
            LED_PIN = LED_OFF;
        }
        GDelay_ms(200);
        if(++gLedFlash_Time >= 10) break;
    }
    GDelay_ms(1000);
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Initialisation de l'interruption externe 0</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GInterruptEx0_Init() {
    IT0 = 1;
    EX0 = 1;
    EA = 1;
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Fonction de rappel de l'interruption externe 0</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GInterruptEx0_Update() interrupt INTERRUPT_EXTERNAL_0 {
    GDelay_ms(200);
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Entrer dans le mode Idle</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GModeIdle_Start() {
    PCON |= 0x01;
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Délai logiciel</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GDelay_ms(uint ms) {
    uint lDelay;
    uint lDelay_ms;
    for(lDelay = 0; lDelay < ms; lDelay++) {
        for(lDelay_ms = 0; lDelay_ms < DELAY_MS; lDelay_ms++);
    }
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Simulation électrique</h3><br><span class="GColor1" style="color:lime;">Diode LED éteinte</span><div class="Img3 GImage"><img src="img/Mode_Idle.png" alt="img/Mode_Idle.png"></div><br><span class="GColor1" style="color:lime;">Diode LED allumée</span><div class="Img3 GImage"><img src="img/Mode_Idle_02.png" alt="img/Mode_Idle_02.png"></div><br><span class="GColor1" style="color:lime;">Une interruption permet de quitter le mode Idle</span><div class="Img3 GImage"><img src="img/Mode_Idle_03.png" alt="img/Mode_Idle_03.png"></div><br><span class="GColor1" style="color:lime;">Le bouton Reset permet de quitter le mode Idle</span><div class="Img3 GImage"><img src="img/Mode_Idle_04.png" alt="img/Mode_Idle_04.png"></div></div></div></div></div><br><div class="Content2 GTitle1"><div class="MainBlock2"><div class="Content"><h1 class="Title2 Center" id="Gérer le mode Power Down"><a class="Link3" href="#">Gérer le mode Power Down</a></h1><div class="Body3">Le but de cette section est de vous apprendre à <span class="GColor1" style="color:lime;">gérer le mode Power Down</span> avec le C 8051.<br>Produit par <b>Gérard KESSE</b>.<br><br>Le mode Power Down permet de passer en mode économie d'énergie en cas d'urgence.<br><br><h3 class="Title8 GTitle3">Programme principal</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void main() {
    GLedFlash_Init();
    GInterruptEx0_Init();
    while(1) {
        GLedFlash_Update();
        GModePowerDown_Start();
    }
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Initialisation de la diode LED</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GLedFlash_Init() {
    LED_PIN = LED_OFF;
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Mise à jour de la diode LED</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GLedFlash_Update() {
    gLedFlash_Time = 0;
    while(1) {
        if(gLedFlash_State == FALSE) {
            gLedFlash_State = TRUE;
            LED_PIN = LED_ON;
        }
        else {
            gLedFlash_State = FALSE;
            LED_PIN = LED_OFF;
        }
        GDelay_ms(200);
        if(++gLedFlash_Time >= 10) break;
    }
    GDelay_ms(1000);
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Initialisation de l'interruption externe 0</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GInterruptEx0_Init() {
    IT0 = 1;
    EX0 = 1;
    EA = 1;
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Fonction de rappel de l'interruption externe 0</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GInterruptEx0_Update() interrupt INTERRUPT_EXTERNAL_0 {
    GDelay_ms(200);
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Entrer dans le mode Power Down</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GInterruptEx0_Update() interrupt INTERRUPT_EXTERNAL_0 {
    GDelay_ms(200);
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Délai logiciel</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GDelay_ms(uint ms) {
    uint lDelay;
    uint lDelay_ms;
    for(lDelay = 0; lDelay < ms; lDelay++) {
        for(lDelay_ms = 0; lDelay_ms < DELAY_MS; lDelay_ms++);
    }
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Simulation électrique</h3><br><span class="GColor1" style="color:lime;">Diode LED éteinte</span><div class="Img3 GImage"><img src="img/Mode_Power_Down.png" alt="img/Mode_Power_Down.png"></div><br><span class="GColor1" style="color:lime;">Diode LED allumée</span><div class="Img3 GImage"><img src="img/Mode_Power_Down_02.png" alt="img/Mode_Power_Down_02.png"></div><br><span class="GColor1" style="color:lime;">Une interruption ne permet pas de quitter le mode Power Down</span><div class="Img3 GImage"><img src="img/Mode_Power_Down_03.png" alt="img/Mode_Power_Down_03.png"></div><br><span class="GColor1" style="color:lime;">Seul le bouton Reset permet de quitter le mode Power Down</span><div class="Img3 GImage"><img src="img/Mode_Power_Down_04.png" alt="img/Mode_Power_Down_04.png"></div></div></div></div></div><br><div class="Content2 GTitle1"><div class="MainBlock2"><div class="Content"><h1 class="Title2 Center" id="Définir une structure boucle infinie améliorée"><a class="Link3" href="#">Définir une structure boucle infinie améliorée</a></h1><div class="Body3">Le but de cette section est de vous apprendre à <span class="GColor1" style="color:lime;">définir une structure boucle infinie améliorée</span> avec le C 8051.<br>Produit par <b>Gérard KESSE</b>.<br><br>La structure logicielle boucle infinie améliorée permet des applications embarquées multitâches.<br><br><h3 class="Title8 GTitle3">Structure logicielle boucle infinie améliorée</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void main() {
    GLedFlash_Init();
    while(1) {
        GLedFlash_Update();
        GDelay_ms(10);
    }
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Initialisation de la diode LED</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GLedFlash_Init() {
    LED_PIN = LED_OFF;
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Mise à jour de la diode LED</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GLedFlash_Update() {
    if(++gLedFlash_Time >= 100) {
        gLedFlash_Time = 0;
        if(gLedFlash_State == FALSE) {
            gLedFlash_State = TRUE;
            LED_PIN = LED_ON;
        }
        else {
            gLedFlash_State = FALSE;
            LED_PIN = LED_OFF;
        }
    }
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Délai logiciel</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GDelay_ms(uint ms) {
    uint lDelay;
    uint lDelay_ms;
    for(lDelay = 0; lDelay < ms; lDelay++) {
        for(lDelay_ms = 0; lDelay_ms < DELAY_MS; lDelay_ms++);
    }
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Simulation électrique</h3><br><span class="GColor1" style="color:lime;">Diode LED éteinte pendant 1s</span><div class="Img3 GImage"><img src="img/Boucle_Infinie_Amelioree.png" alt="img/Boucle_Infinie_Amelioree.png"></div><br><span class="GColor1" style="color:lime;">Diode LED allumée pendant 1s</span><div class="Img3 GImage"><img src="img/Boucle_Infinie_Amelioree_02.png" alt="img/Boucle_Infinie_Amelioree_02.png"></div><br><span class="GColor1" style="color:lime;">Oscilloscope</span><div class="Img3 GImage"><img src="img/Boucle_Infinie_Amelioree_03.png" alt="img/Boucle_Infinie_Amelioree_03.png"></div></div></div></div></div><br><div class="Content2 GTitle1"><div class="MainBlock2"><div class="Content"><h1 class="Title2 Center" id="Lire et écrire sur un port"><a class="Link3" href="#">Lire et écrire sur un port</a></h1><div class="Body3">Le but de cette section est de vous apprendre à <span class="GColor1" style="color:lime;">lire et écrire sur un port</span> avec le C 8051.<br>Produit par <b>Gérard KESSE</b>.<br><br><h3 class="Title8 GTitle3">Programme principal</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void main() {
    GPortReadWrite_Init();
    while(1) {
        GPortReadWrite_Update();
        GDelay_ms(10);
    }
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Initialisation des ports</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GPortReadWrite_Init() {
    WRITE_PORT = PORT_OFF;
    READ_PORT = 0xFF;
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Lire et écrire sur un port</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GPortReadWrite_Update() {
    if(++gPortReadWrite_Time >= 20) {
        gPortReadWrite_Time = 0;
        gPortReadWrite_Value = READ_PORT;
        WRITE_PORT = gPortReadWrite_Value;
    }
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Délai logiciel</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GDelay_ms(uint ms) {
    uint lDelay;
    uint lDelay_ms;
    for(lDelay = 0; lDelay < ms; lDelay++) {
        for(lDelay_ms = 0; lDelay_ms < DELAY_MS; lDelay_ms++);
    }
}
//===============================================</xmp></pre></div><br><br><h3 class="Title8 GTitle3">Simulation électrique</h3><br><span class="GColor1" style="color:lime;">Lecture du port P1 et écriture sur le port P2</span><div class="Img3 GImage"><img src="img/Port_Lecture_Ecriture.png" alt="img/Port_Lecture_Ecriture.png"></div></div></div></div></div><br><div class="Content2 GTitle1"><div class="MainBlock2"><div class="Content"><h1 class="Title2 Center" id="Lire et écrire sur une broche"><a class="Link3" href="#">Lire et écrire sur une broche</a></h1><div class="Body3">Le but de cette section est de vous apprendre à <span class="GColor1" style="color:lime;">lire et écrire sur une broche</span> avec le C 8051.<br>Produit par <b>Gérard KESSE</b>.<br><br><h3 class="Title8 GTitle3">Programme principal</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void main() {
    GPinReadWrite_Init();
    while(1) {
        GPinReadWrite_Update();
        GDelay_ms(10);
    }
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Initialisation des broches</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GPinReadWrite_Init() {
    WRITE_PIN = LED_OFF;
    READ_PIN = 1;
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Lire et écrire sur une broche</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GPinReadWrite_Update() {
    if(++gPinReadWrite_Time >= 20) {
        gPinReadWrite_Time = 0;
        gPinReadWrite_Value = READ_PIN;
        WRITE_PIN = gPinReadWrite_Value;
    }
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Délai logiciel</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GDelay_ms(uint ms) {
    uint lDelay;
    uint lDelay_ms;
    for(lDelay = 0; lDelay < ms; lDelay++) {
        for(lDelay_ms = 0; lDelay_ms < DELAY_MS; lDelay_ms++);
    }
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Simulation électrique</h3><br><span class="GColor1" style="color:lime;">Diode LED éteinte</span><div class="Img3 GImage"><img src="img/Pin_Lecture_Ecriture.png" alt="img/Pin_Lecture_Ecriture.png"></div><br><span class="GColor1" style="color:lime;">Diode LED allumée</span><div class="Img3 GImage"><img src="img/Pin_Lecture_Ecriture_02.png" alt="img/Pin_Lecture_Ecriture_02.png"></div></div></div></div></div><br><div class="Content2 GTitle1"><div class="MainBlock2"><div class="Content"><h1 class="Title2 Center" id="Réaliser des opérations logiques bit à bit"><a class="Link3" href="#">Réaliser des opérations logiques bit à bit</a></h1><div class="Body3">Le but de cette section est de vous apprendre à <span class="GColor1" style="color:lime;">réaliser des opérations logiques bit à bit</span> avec le C 8051.<br>Produit par <b>Gérard KESSE</b>.<br><br><h3 class="Title8 GTitle3">Programme principal</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void main() {
    GRS232_Init();
    GBitOperator_Init();
    while(1);
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Initialisation de la communication RS232</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GRS232_Init() {
    TMOD = 0x20;
    SCON = 0x50;
    TH1 = 0xFD;
    ES = 0;
    TR1 = 1;
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Écrire un caractère sur le port RS232</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GRS232_Write_Char(char c) {
	char lData = c;
	if(c == '\n') lData = 0x0D;
	SBUF = lData;		
	while (TI == 0);		
	TI = 0;			
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Écrire une chaine de caractères sur le port RS232</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GRS232_Write_String(const char* d) {
    uchar i = 0;
    while(d[i] != 0) {
        GRS232_Write_Char(d[i++]);
    }
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Écrire un nombre entier sur le port RS232</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GRS232_Write_Int(uint d, uchar MAX) {
    uint lData = d;
    uint lData2;
    uchar lDigits = GRS232_Get_Digits_Int(d);
    uchar i;
        
    if(MAX == 0 || MAX < lDigits) MAX = lDigits;
    i = MAX;
    while(1) {
        i--;
        lData2 = lData / GRS232_Get_Pow(10, i);
        lData = lData % GRS232_Get_Pow(10, i);
        GRS232_Write_Char(HEXA_MAP[lData2]);
        if(i == 0) break;
    }
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Réaliser des opérations logiques bit à bit</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GBitOperator_Init() {
    uchar A = 0xFE;
    uchar B = 0x0F;
    uint C = 0x0A0B;
    uchar lData = 0;
    uint lData2 = 0;
    
    GRS232_Write_String("\n### Operations sur les bits\n\n");
    GRS232_Write_String_Space("A ", 30, '.');
    GRS232_Write_Hexa(A, 2);    
    GRS232_Write_String(" = ");
    GRS232_Write_Bin(A, 8);    
    GRS232_Write_String(" = ");
    GRS232_Write_Int(A, 0);    
    GRS232_Write_String("\n");
    
    GRS232_Write_String_Space("B ", 30, '.');
    GRS232_Write_Hexa(B, 2);    
    GRS232_Write_String(" = ");
    GRS232_Write_Bin(A, 8);    
    GRS232_Write_String(" = ");
    GRS232_Write_Int(B, 0);    
    GRS232_Write_String("\n");
    
    GRS232_Write_String_Space("C ", 30, '.');
    GRS232_Write_Hexa(C, 4);    
    GRS232_Write_String(" = ");
    GRS232_Write_Bin(A, 8);    
    GRS232_Write_String(" = ");
    GRS232_Write_Int(C, 0);    
    GRS232_Write_String("\n");
    
    GRS232_Write_String("\n### Operateur Complementaire\n\n");
    lData = A;
    GRS232_Write_String_Space("A ", 30, '.');
    GRS232_Write_Bin(lData, 8);    
    GRS232_Write_String(" = ");
    GRS232_Write_Hexa(lData, 2);    
    GRS232_Write_String("\n");
    lData = ~A;
    GRS232_Write_String_Space("Complementaire(A) ", 30, '.');
    GRS232_Write_Bin(lData, 8);    
    GRS232_Write_String(" = ");
    GRS232_Write_Hexa(lData, 2);    
    GRS232_Write_String("\n");
    
    GRS232_Write_String("\n### Operateur ET Logique\n\n");
    lData = A;
    GRS232_Write_String_Space("A ", 30, '.');
    GRS232_Write_Bin(lData, 8);    
    GRS232_Write_String(" = ");
    GRS232_Write_Hexa(lData, 2);    
    GRS232_Write_String("\n");
    lData = B;
    GRS232_Write_String_Space("B ", 30, '.');
    GRS232_Write_Bin(lData, 8);    
    GRS232_Write_String(" = ");
    GRS232_Write_Hexa(lData, 2);    
    GRS232_Write_String("\n");
    lData = A & B;
    GRS232_Write_String_Space("ET Logique(A, B) ", 30, '.');
    GRS232_Write_Bin(lData, 8);    
    GRS232_Write_String(" = ");
    GRS232_Write_Hexa(lData, 2);    
    GRS232_Write_String("\n");
    
    GRS232_Write_String("\n### Operateur OU Logique\n\n");
    lData = A;
    GRS232_Write_String_Space("A ", 30, '.');
    GRS232_Write_Bin(lData, 8);    
    GRS232_Write_String(" = ");
    GRS232_Write_Hexa(lData, 2);    
    GRS232_Write_String("\n");
    lData = B;
    GRS232_Write_String_Space("B ", 30, '.');
    GRS232_Write_Bin(lData, 8);    
    GRS232_Write_String(" = ");
    GRS232_Write_Hexa(lData, 2);    
    GRS232_Write_String("\n");
    lData = A | B;
    GRS232_Write_String_Space("OU Logique(A, B) ", 30, '.');
    GRS232_Write_Bin(lData, 8);    
    GRS232_Write_String(" = ");
    GRS232_Write_Hexa(lData, 2);    
    GRS232_Write_String("\n");
    
    GRS232_Write_String("\n### Operateur OU Exclusif\n\n");
    lData = A;
    GRS232_Write_String_Space("A ", 30, '.');
    GRS232_Write_Bin(lData, 8);    
    GRS232_Write_String(" = ");
    GRS232_Write_Hexa(lData, 2);    
    GRS232_Write_String("\n");
    lData = B;
    GRS232_Write_String_Space("B ", 30, '.');
    GRS232_Write_Bin(lData, 8);    
    GRS232_Write_String(" = ");
    GRS232_Write_Hexa(lData, 2);    
    GRS232_Write_String("\n");
    lData = A ^ B;
    GRS232_Write_String_Space("OU Exclusif(A, B) ", 30, '.');
    GRS232_Write_Bin(lData, 8);    
    GRS232_Write_String(" = ");
    GRS232_Write_Hexa(lData, 2);    
    GRS232_Write_String("\n");
    
    GRS232_Write_String("\n### Operateur Decalage Gauche\n\n");
    lData = A;
    GRS232_Write_String_Space("A ", 30, '.');
    GRS232_Write_Bin(lData, 8);    
    GRS232_Write_String(" = ");
    GRS232_Write_Hexa(lData, 2);    
    GRS232_Write_String("\n");
    lData = A << 2;
    GRS232_Write_String_Space("Decalage Gauche(A, 2) ", 30, '.');
    GRS232_Write_Bin(lData, 8);    
    GRS232_Write_String(" = ");
    GRS232_Write_Hexa(lData, 2);    
    GRS232_Write_String("\n");
    
    GRS232_Write_String("\n### Operateur Decalage Droite\n\n");
    lData = A;
    GRS232_Write_String_Space("A ", 30, '.');
    GRS232_Write_Bin(lData, 8);    
    GRS232_Write_String(" = ");
    GRS232_Write_Hexa(lData, 2);    
    GRS232_Write_String("\n");
    lData = A >> 2;
    GRS232_Write_String_Space("Decalage Droite(A, 2) ", 30, '.');
    GRS232_Write_Bin(lData, 8);    
    GRS232_Write_String(" = ");
    GRS232_Write_Hexa(lData, 2);    
    GRS232_Write_String("\n");
    
    GRS232_Write_String("\n### Octet Fort & Faible\n\n");
    lData2 = C;
    GRS232_Write_String_Space("C ", 30, '.');
    GRS232_Write_Bin(lData2, 16);    
    GRS232_Write_String(" = ");
    GRS232_Write_Hexa(lData2, 4);    
    GRS232_Write_String("\n");
    lData = C >> 8;
    GRS232_Write_String_Space("Octet Fort(C) ", 30, '.');
    GRS232_Write_Bin(lData, 8);    
    GRS232_Write_String(" = ");
    GRS232_Write_Hexa(lData, 2);    
    GRS232_Write_String("\n");
    lData = C & 0xFF;
    GRS232_Write_String_Space("Octet Faible(C) ", 30, '.');
    GRS232_Write_Bin(lData, 8);    
    GRS232_Write_String(" = ");
    GRS232_Write_Hexa(lData, 2);    
    GRS232_Write_String("\n");
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Simulation électrique</h3><br><span class="GColor1" style="color:lime;">Connexion du microcontrôleur au port RS232</span><div class="Img3 GImage"><img src="img/Operation_Bit.png" alt="img/Operation_Bit.png"></div><br><span class="GColor1" style="color:lime;">Affichage des données sur le Terminal</span><div class="Img3 GImage"><img src="img/Operation_Bit_02.png" alt="img/Operation_Bit_02.png"></div></div></div></div></div><br><div class="Content2 GTitle1"><div class="MainBlock2"><div class="Content"><h1 class="Title2 Center" id="Lire et écrire sur une broche via un port"><a class="Link3" href="#">Lire et écrire sur une broche via un port</a></h1><div class="Body3">Le but de cette section est de vous apprendre à <span class="GColor1" style="color:lime;">lire et écrire sur une broche via un port</span> avec le C 8051.<br>Produit par <b>Gérard KESSE</b>.<br><br><h3 class="Title8 GTitle3">Programme principal</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void main() {
    GPinReadWrite_Init();
    while(1) {
        GPinReadWrite_Update();
    }
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Initialisation des broches</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GPinReadWrite_Init() {
    GPinReadWrite_Write_Bit(7, 1);
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Mise à jour des broches</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GPinReadWrite_Update() {
    gPinReadWrite_Value = GPinReadWrite_Read_Bit(0);
    GPinReadWrite_Write_Bit(7, gPinReadWrite_Value);
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Écrire sur une broche via un port</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GPinReadWrite_Write_Bit(uchar pin, bit d) {
    uchar lWrite = 0x01;
    lWrite <<= pin;
    if(d == 1) {
        RW_PORT |= lWrite;
    }
    else {
        RW_PORT &= (~lWrite);
    }
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Lire une broche via un port</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
bit GPinReadWrite_Read_Bit(uchar pin) {
    uchar lRead = 0x01;
    lRead <<= pin;
    GPinReadWrite_Write_Bit(pin, 1);
    if(lRead & RW_PORT) return 1;
    return 0;
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Simulation électrique</h3><br><span class="GColor1" style="color:lime;">Diode LED éteinte</span><div class="Img3 GImage"><img src="img/Pin_Port_Lecture_Ecriture.png" alt="img/Pin_Port_Lecture_Ecriture.png"></div><br><span class="GColor1" style="color:lime;">Diode LED allumée</span><div class="Img3 GImage"><img src="img/Pin_Port_Lecture_Ecriture_02.png" alt="img/Pin_Port_Lecture_Ecriture_02.png"></div></div></div></div></div><br><div class="Content2 GTitle1"><div class="MainBlock2"><div class="Content"><h1 class="Title2 Center" id="Gérer les temps de rebonds d'un bouton"><a class="Link3" href="#">Gérer les temps de rebonds d'un bouton</a></h1><div class="Body3">Le but de cette section est de vous apprendre à <span class="GColor1" style="color:lime;">gérer les temps de rebond d'un bouton</span> avec le C 8051.<br>Produit par <b>Gérard KESSE</b>.<br><br>Les interrupteurs mécaniques, en pratique, rebondissent à plusieurs reprises, pendant une courte période, de l'ordre de 30 ms après la fermeture ou l’ouverture du commutateur.<br><br><h3 class="Title8 GTitle3">Programme principal</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void main() {
    GDebounce_Init();
    while(1) {
        GDebounce_Update();
    }
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Initialisation des broches</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GDebounce_Init() {
    SWITCH_PIN = 1;
    OUTPUT_PORT = OUTPUT_RELEASED;
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Mise à jour des broches</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GDebounce_Update() {
    gDebounce_State = GDebounce_Read_Input(30);
    GDebounce_Write_Output(gDebounce_State);
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Gérer les temps de rebonds</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
bit GDebounce_Read_Input(uchar debounce) {
    bit lState = SWITCH_RELEASED;
    if(SWITCH_PIN == 0) {
        GDelay_ms(debounce);
        if(SWITCH_PIN == 0) {
            lState = SWITCH_PRESSED;
        }
    }
    return lState;
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Exploiter l'état de l'interrupteur<br></h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GDebounce_Write_Output(bit state) {
    if(state == SWITCH_PRESSED) {
        OUTPUT_PORT = OUTPUT_PRESSED;
    }
    else {
        OUTPUT_PORT = OUTPUT_RELEASED;
    }
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Simulation électrique</h3><br><span class="GColor1" style="color:lime;">Interrupteur relâché</span><br><div class="Img3 GImage"><img src="img/Temps_Rebonds.png" alt="img/Temps_Rebonds.png"></div><br><span class="GColor1" style="color:lime;">Interrupteur pressé</span><br><div class="Img3 GImage"><img src="img/Temps_Rebonds_02.png" alt="img/Temps_Rebonds_02.png"></div></div></div></div></div><br><div class="Content2 GTitle1"><div class="MainBlock2"><div class="Content"><h1 class="Title2 Center" id="Compter le nombre d'appui sur un bouton"><a class="Link3" href="#">Compter le nombre d'appui sur un bouton</a></h1><div class="Body3">Le but de cette section est de vous apprendre à <span class="GColor1" style="color:lime;">compter le nombre d'appui sur un bouton</span> avec le C 8051.<br>Produit par <b>Gérard KESSE</b>.<br><br><h3 class="Title8 GTitle3">Programme principal</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void main() {
    GDebounce_Init();
    while(1) {
        GDebounce_Update();
    }
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Initialisation des broches</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GDebounce_Init() {
    SWITCH_PIN = 1;
    COUNTER_PORT = COUNTER_OFF;
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Compter le nombre d'appui sur le bouton</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GDebounce_Update() {
    gDebounce_State = GDebounce_Read_Input(30);
    if(gDebounce_State == SWITCH_PRESSED) gDebounce_Count++;
    GDebounce_Write_Output(gDebounce_Count);
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Lire l'état du bouton</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
bit GDebounce_Read_Input(uchar debounce) {
    bit lState = SWITCH_RELEASED;
    if(SWITCH_PIN == 0) {
        GDelay_ms(debounce);
        if(SWITCH_PIN == 0) {
            while(SWITCH_PIN == 0);
            lState = SWITCH_PRESSED;
        }
    }
    return lState;
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Mise à jour du compteur</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GDebounce_Write_Output(uint count) {
    COUNTER_PORT = ~count;
}
//===============================================
</xmp></pre></div><br><h3 class="Title8 GTitle3">Simulation électrique</h3><br><span class="GColor1" style="color:lime;">Compteur à 0</span><br><div class="Img3 GImage"><img src="img/Temps_Rebonds_Comptage.png" alt="img/Temps_Rebonds_Comptage.png"></div><br><span class="GColor1" style="color:lime;">Compteur à 1</span><br><div class="Img3 GImage"><img src="img/Temps_Rebonds_Comptage_02.png" alt="img/Temps_Rebonds_Comptage_02.png"></div><br><span class="GColor1" style="color:lime;">Compteur à 2</span><br><div class="Img3 GImage"><img src="img/Temps_Rebonds_Comptage_03.png" alt="img/Temps_Rebonds_Comptage_03.png"></div><br><span class="GColor1" style="color:lime;">Compteur à 3</span><div class="Img3 GImage"><img src="img/Temps_Rebonds_Comptage_04.png" alt="img/Temps_Rebonds_Comptage_04.png"></div></div></div></div></div><br><div class="Content2 GTitle1"><div class="MainBlock2"><div class="Content"><h1 class="Title2 Center" id="Gérer les délais matériels Timer T0"><a class="Link3" href="#">Gérer les délais matériels Timer T0</a></h1><div class="Body3">Le but de cette section est de vous apprendre à <span class="GColor1" style="color:lime;">gérer les délais matériels Timer T0</span> avec le C 8051.<br>Produit par <b>Gérard KESSE</b>.<br><br>Un Timer permet de mesurer des durées pour une bonne synchronisation des opérations.<br><br><h3 class="Title8 GTitle3">Programme principal</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void main() {
    GLedFlash_Init();
    while(1) {
        GLedFlash_Update();
        GDelay_ms(10);
    }
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Initialisation de la diode LED</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GLedFlash_Init() {
    LED_PIN = LED_OFF;
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Mise à jour de la diode LED</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GLedFlash_Update() {
    if(++gLedFlash_Time >= 100) {
        gLedFlash_Time = 0;
        if(gLedFlash_State == FALSE) {
            gLedFlash_State = TRUE;
            LED_PIN = LED_ON;
        }
        else {
            gLedFlash_State = FALSE;
            LED_PIN = LED_OFF;
        }
    }
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Délai matériel Timer T0</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GDelay_ms(uint ms) {
    uint lDelay;
    
    TMOD &= 0xF0;
    TMOD |= 0x01;
    ET0 = 0; 

    for(lDelay = 0; lDelay < ms; lDelay++) {
        TH0 = PRELOADH;
        TL0 = PRELOADL;
        TF0 = 0;
        TR0 = 1;
        while (TF0 == 0);
        TR0 = 0;
    }
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Simulation électrique</h3><br><span class="GColor1" style="color:lime;">Diode LED éteinte</span><div class="Img3 GImage"><img src="img/Delai_Materiel_Timer_T0.png" alt="img/Delai_Materiel_Timer_T0.png"></div><br><span class="GColor1" style="color:lime;">Diode LED allumée</span><div class="Img3 GImage"><img src="img/Delai_Materiel_Timer_T0_02.png" alt="img/Delai_Materiel_Timer_T0_02.png"></div><br><span class="GColor1" style="color:lime;">Forme d'onde</span><div class="Img3 GImage"><img src="img/Delai_Materiel_Timer_T0_03.png" alt="img/Delai_Materiel_Timer_T0_03.png"></div></div></div></div></div><br><div class="Content2 GTitle1"><div class="MainBlock2"><div class="Content"><h1 class="Title2 Center" id="Gérer la sécurité avec les Timeouts"><a class="Link3" href="#">Gérer la sécurité avec les Timeouts</a></h1><div class="Body3">Le but de cette section est de vous apprendre à <span class="GColor1" style="color:lime;">gérer la sécurité système avec les Timeouts</span> avec le C 8051.<br>Produit par <b>Gérard KESSE</b>.<br><br>Un Timeout permet d'éviter le blocage du système à une étape donnée du traitement.<br><br><h3 class="Title8 GTitle3">Programme principal</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void main() {
    GDebounce_Init();
    while(1) {
        GDebounce_Update();
    }
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Initialisation des broches</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GDebounce_Init() {
    SWITCH_PIN = 1;
    COUNTER_PORT = COUNTER_OFF;
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Mise à jour des broches</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GDebounce_Update() {
    gDebounce_State = GDebounce_Read_Input(30);
    if(gDebounce_State == SWITCH_PRESSED) gDebounce_Count++;
    GDebounce_Write_Output(gDebounce_Count);
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Mise en place du Timeout</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
bit GDebounce_Read_Input(uchar debounce) {
    bit lState = SWITCH_RELEASED;
    ulong lTimeout = LOOP_TIMEOUT_INIT_1000ms;
    
    if(SWITCH_PIN == 0) {
        GDelay_ms(debounce);
        if(SWITCH_PIN == 0) {
            while((SWITCH_PIN == 0) && (++lTimeout != 0));
            if (lTimeout == 0) {
                lState = SWITCH_RELEASED;
                TIMEOUT_PIN = !TIMEOUT_PIN;
            }
            else {
                lState = SWITCH_PRESSED;
            }
        }
    }
    
    return lState;
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Simulation électrique</h3><br><span class="GColor1" style="color:lime;">Compteur à 5</span><div class="Img3 GImage"><img src="img/Timeout.png" alt="img/Timeout.png"></div><br><span class="GColor1" style="color:lime;">Compteur à 5 (Forme d'onde)</span><div class="Img3 GImage"><img src="img/Timeout_02.png" alt="img/Timeout_02.png"></div><br><span class="GColor1" style="color:lime;">Exécution du Timeout</span><div class="Img3 GImage"><img src="img/Timeout_03.png" alt="img/Timeout_03.png"></div><br><span class="GColor1" style="color:lime;">Exécution du Timeout (Forme d'onde)</span><div class="Img3 GImage"><img src="img/Timeout_04.png" alt="img/Timeout_04.png"></div></div></div></div></div><br><br><div class="Content2 GTitle1"><div class="MainBlock2"><div class="Content"><h1 class="Title2 Center" id="Gérer les interruptions Timer T2"><a class="Link3" href="#">Gérer les interruptions Timer T2</a></h1><div class="Body3">Le but de cette section est de vous apprendre à <span class="GColor1" style="color:lime;">gérer les interruptions Timer T2</span> avec le C 8051.<br>Produit par <b>Gérard KESSE</b>.<br><br>Une interruption permet d’effectuer des communications non bloquantes avec des périphériques externes.<br><br><h3 class="Title8 GTitle3">Programme principal</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void main() {
    GLedFlash_Init();
    GInterruptT2_Init(1);
    GInterruptT2_Start();
    while(1);
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Initialisation de la diode LED</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GLedFlash_Init() {
    LED_PIN = LED_OFF;
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Mise à jour de la diode LED</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GLedFlash_Update() {
    if(++gLedFlash_Time >= 1000) {
        gLedFlash_Time = 0;
        if(gLedFlash_State == FALSE) {
            gLedFlash_State = TRUE;
            LED_PIN = LED_ON;
        }
        else {
            gLedFlash_State = FALSE;
            LED_PIN = LED_OFF;
        }
    }
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Initialisation du Timer T2</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GInterruptT2_Init(uint ms) {
    uint lPreload = 65536 - ((OSC_FREQ * ms) / (OSC_PER_INST * 1000));
    uchar lPreloadH = lPreload / 256;
    uchar lPreloadL = lPreload % 256;
    
    T2CON = 0x00; 
    TH2 = lPreloadH; 
    RCAP2H = lPreloadH; 
    TL2 = lPreloadL; 
    RCAP2L = lPreloadL;
    ET2 = 1;
    TR2 = 1;
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Autorisation des interruptions</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GInterruptT2_Start() {
    EA = 1;
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Fonction de rappel de l'interruptions Timer T2</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GInterruptT2_Update() interrupt INTERRUPT_TIMER_T2 {
    TF2 = 0;
    GLedFlash_Update();
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Simulation électrique</h3><br><span class="GColor1" style="color:lime;">Diode LED éteinte pendant 1s<br></span><div class="Img3 GImage"><img src="img/Interruption_Timer_T2.png" alt="img/Interruption_Timer_T2.png"></div><br><span class="GColor1" style="color:lime;">Diode LED allumée pendant 1s<br></span><div class="Img3 GImage"><img src="img/Interruption_Timer_T2_02.png" alt="img/Interruption_Timer_T2_02.png"></div><br><span class="GColor1" style="color:lime;">Forme d'onde (Les délais sont précis)<br></span><div class="Img3 GImage"><img src="img/Interruption_Timer_T2_03.png" alt="img/Interruption_Timer_T2_03.png"></div></div></div></div></div><br><div class="Content2 GTitle1"><div class="MainBlock2"><div class="Content"><h1 class="Title2 Center" id="Définir un système d'exploitation embarqué simple Timer T2"><a class="Link3" href="#">Définir un système d'exploitation embarqué simple Timer T2</a></h1><div class="Body3">Le but de cette section est de vous apprendre à <span class="GColor1" style="color:lime;">définir un système d'exploitation embarqué simple</span> à base du <span class="GColor1" style="color:lime;">Timer T2</span> avec le C 8051.<br>Produit par <b>Gérard KESSE</b>.<br><br>Le <b>sEOS</b> (Simple Embedded Operating Système) permet gérer des applications embarquées multitâches temps réel.<br><br><h3 class="Title8 GTitle3">Programme principal</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void main() {
	GSeos_Init(1);
	GLedFlash_Init();
	GSeos_Start();
    
	while(1) {
	    GSeos_Go_To_Sleep();
	}
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Initialisation du sEOS</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GSeos_Init(uchar ms) {
    uint lPreload = (65536 - ((OSC_FREQ * ms) / (OSC_PER_INST * 1000)));
    uchar lPreloadH = (lPreload / 256);
    uchar lPreloadL = (lPreload % 256);
    
    T2CON = 0x00; 
    TH2 = lPreloadH; 
    RCAP2H = lPreloadH; 
    TL2 = lPreloadL; 
    RCAP2L = lPreloadL;
    ET2 = 1;
    TR2 = 1;
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Entrer en mode Idle sEOS</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GSeos_Go_To_Sleep() {
    PCON |= 0x01;
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Démarrage du sEOS</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GSeos_Start() {
    EA = 1;
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Mise à jour du sEOS</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GSeos_Update() interrupt INTERRUPT_TIMER_T2 {    
    TF2 = 0;
    GLedFlash_Update();
}
//===============================================
</xmp></pre></div><br><h3 class="Title8 GTitle3">Initialisation des broches</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GLedFlash_Init() {
    LED_PIN = LED_OFF;
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Mise à jour des proches</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GLedFlash_Update() {
    if(++gLedFlash_Time >= 1000) {
        gLedFlash_Time = 0;
        if(gLedFlash_State == FALSE) {
            gLedFlash_State = TRUE;
            LED_PIN = LED_ON;
        }
        else {
            gLedFlash_State = FALSE;
            LED_PIN = LED_OFF;
        }
    }
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Simulation électrique</h3><br><span class="GColor1" style="color:lime;">Diode LED éteinte pendant 1s</span><div class="Img3 GImage"><img src="img/SEOS_Timer_T2.png" alt="img/SEOS_Timer_T2.png"></div><br><span class="GColor1" style="color:lime;">Diode LED allumée pendant 1s</span><div class="Img3 GImage"><img src="img/SEOS_Timer_T2_02.png" alt="img/SEOS_Timer_T2_02.png"></div><br><span class="GColor1" style="color:lime;">Forme d'onde (Les délais sont très précis)</span><div class="Img3 GImage"><img src="img/SEOS_Timer_T2_03.png" alt="img/SEOS_Timer_T2_03.png"></div><br><span class="GColor1" style="color:lime;">Analyse de performance (Processeur en mode Idle à 91.9 % du temps)</span><div class="Img3 GImage"><img src="img/SEOS_Timer_T2_04.png" alt="img/SEOS_Timer_T2_04.png"></div></div></div></div></div><br><div class="Content2 GTitle1"><div class="MainBlock2"><div class="Content"><h1 class="Title2 Center" id="Définir un système d'exploitation embarqué simple Timer T0"><a class="Link3" href="#">Définir un système d'exploitation embarqué simple Timer T0</a></h1><div class="Body3">Le but de cette section est de vous apprendre à <span class="GColor1" style="color:lime;">définir un système d'exploitation embarqué simple</span> à base du <span class="GColor1" style="color:lime;">Timer T0</span> avec le C 8051.<br>Produit par <b>Gérard KESSE</b>.<br><br>Le <b>sEOS</b> (Simple Embedded Operating Système) permet gérer des applications embarquées multitâches temps réel.<br><br><h3 class="Title8 GTitle3">Programme principal</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void main() {
	GSeos_Init(1);
	GLedFlash_Init();
	GSeos_Start();
    
	while(1) {
	    GSeos_Go_To_Sleep();
	}
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Initialisation du sEOS</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GSeos_Init(uchar ms) {
    uint lPreload = (65536 - ((OSC_FREQ * ms) / (OSC_PER_INST * 1000)));
    gPreloadH = (lPreload / 256);
    gPreloadL = (lPreload % 256);
    
    TMOD &= 0xF0;
    TMOD |= 0x01;
    TH0 = gPreloadH;
    TL0 = gPreloadL;
    ET0 = 1;
    TR0 = 1;
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Entrer en mode Idle sEOS</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GSeos_Go_To_Sleep() {
    PCON |= 0x01;
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Démarrage du sEOS</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GSeos_Start() {
    EA = 1;
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Rechargement du Timer T0 en mode 16-bit</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GSeos_Reload() {  
    TR0 = 0;
    TH0 = gPreloadH;
    TL0 = gPreloadL;
    TR0 = 1;
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Mise à jour du sEOS</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GSeos_Update() interrupt INTERRUPT_TIMER_T0 {    
    GSeos_Reload();
    GLedFlash_Update();
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Simulation électrique</h3><br><span class="GColor1" style="color:lime;">Diode LED éteinte pendant 1s</span><br><div class="Img3 GImage"><img src="img/SEOS_Timer_T0.png" alt="img/SEOS_Timer_T0.png"></div><br><span class="GColor1" style="color:lime;">Diode LED allumée pendant 1s</span><br><div class="Img3 GImage"><img src="img/SEOS_Timer_T0_02.png" alt="img/SEOS_Timer_T0_02.png"></div><br><span class="GColor1" style="color:lime;">Forme d'onde (Influence du temps de rechargement du Timer T0)</span><br><div class="Img3 GImage"><img src="img/SEOS_Timer_T0_03.png" alt="img/SEOS_Timer_T0_03.png"></div><br><span class="GColor1" style="color:lime;">Analyse de performance (Processeur en mode Idle à 91.2 % du temps)</span><br><div class="Img3 GImage"><img src="img/SEOS_Timer_T0_04.png" alt="img/SEOS_Timer_T0_04.png"></div></div></div></div></div><br><div class="Content2 GTitle1"><div class="MainBlock2"><div class="Content"><h1 class="Title2 Center" id="Gérer les machines à états finis"><a class="Link3" href="#">Gérer les machines à états finis</a></h1><div class="Body3">Le but de cette section est de vous apprendre à <span class="GColor1" style="color:lime;">gérer les machines à états finis</span> avec le C 8051.<br>Produit par <b>Gérard KESSE.</b><br><br>Le structure logicielle machine à états finis permet de gérer des applications embarqués sous la forme d'une séquences d'états finis.<br><br><h3 class="Title8 GTitle3">Programme principal</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void main() {
	GSeos_Init(1);
	GTrafficLights_Init();
	GSeos_Start();
    
	while(1) {
	    GSeos_Go_To_Sleep();
	}
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Simulation électrique</h3><br><span class="GColor1" style="color:lime;">Système de gestion de feux tricolores</span><div class="Img3 GImage"><img src="img/Machine_Etats_Finis_SEOS.png" alt="img/Machine_Etats_Finis_SEOS.png"></div><br><span class="GColor1" style="color:lime;">Voie 1 ROUGE - Voie 2 VERT</span><div class="Img3 GImage"><img src="img/Machine_Etats_Finis_SEOS_02.png" alt="img/Machine_Etats_Finis_SEOS_02.png"></div><br><span class="GColor1" style="color:lime;">Voie 1 ROUGE - Voie 2 ORANGE</span><div class="Img3 GImage"><img src="img/Machine_Etats_Finis_SEOS_03.png" alt="img/Machine_Etats_Finis_SEOS_03.png"></div><br><span class="GColor1" style="color:lime;">Voie 1 ROUGE - Voie 2 ROUGE </span><div class="Img3 GImage"><img src="img/Machine_Etats_Finis_SEOS_04.png" alt="img/Machine_Etats_Finis_SEOS_04.png"></div><br><span class="GColor1" style="color:lime;">Voie 1 VERT - Voie 2 ROUGE </span><div class="Img3 GImage"><img src="img/Machine_Etats_Finis_SEOS_05.png" alt="img/Machine_Etats_Finis_SEOS_05.png"></div><br><span class="GColor1" style="color:lime;">Voie 1 ORANGE- Voie 2 ROUGE</span><div class="Img3 GImage"><img src="img/Machine_Etats_Finis_SEOS_06.png" alt="img/Machine_Etats_Finis_SEOS_06.png"></div><br><span class="GColor1" style="color:lime;">Voie 1 ROUGE - Voie 2 ROUGE</span><div class="Img3 GImage"><img src="img/Machine_Etats_Finis_SEOS_07.png" alt="img/Machine_Etats_Finis_SEOS_07.png"></div><br><span class="GColor1" style="color:lime;">Forme d'onde (Voie 1)<br></span><div class="Img3 GImage"><img src="img/Machine_Etats_Finis_SEOS_08.png" alt="img/Machine_Etats_Finis_SEOS_08.png"></div><br><span class="GColor1" style="color:lime;">Forme d'onde (Voie 2)<br></span><div class="Img3 GImage"><img src="img/Machine_Etats_Finis_SEOS_09.png" alt="img/Machine_Etats_Finis_SEOS_09.png"></div></div></div></div></div><br><div class="Content2 GTitle1"><div class="MainBlock2"><div class="Content"><h1 class="Title2 Center" id="Gérer les communications RS232"><a class="Link3" href="#">Gérer les communications RS232</a></h1><div class="Body3">Le but de cette section est de vous apprendre à <span class="GColor1" style="color:lime;">gérer les communications RS232</span> avec le C 8051.<br>Produit par <b>Gérard KESSE</b>.<br><br>Le protocole RS232 permet d’effectuer des communications entre le microcontrôleur et l'ordinateur.<br><br><h3 class="Title8 GTitle3">Programme principal</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void main() {
    GSeos_Init(5);
    GRS232_Init(9600);
    GTimeElapse_Init();
    GLedFlash_Init();
    GSeos_Start();
    
    while(1) {
        GSeos_Go_To_Sleep();
    }
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Mise à jour du sEOS</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GSeos_Update() interrupt INTERRUPT_TIMER_T2 {    
    TF2 = 0;
    GRS232_Update();
    GTimeElapse_Update();
    GLedFlash_Update();
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Initialisation de la communication RS232</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GRS232_Init(uint aBaudRate) {
    uchar lPreload = (256 - (uchar)((((ulong)OSC_FREQ / 100) * 3125)
    / ((ulong)aBaudRate * OSC_PER_INST * 1000)));

    TMOD |= 0x20;
    SCON = 0x50;
    TH1 = lPreload;
    TL1 = lPreload;
    ES = 0;
    TR1 = 1;
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Mise à jour de la communication RS232</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GRS232_Update() {
    if(gTrans_Write_Index < gTrans_Buffer_Index) {
        GRS232_Send_Char(gTrans_Buffer[gTrans_Write_Index]);
        gTrans_Write_Index++;
    }
    else {
        gTrans_Write_Index = 0;
        gTrans_Buffer_Index = 0;
    }
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Envoyer un caractère via RS232</h3><div class="GCode1"><pre class="Code2"><xmp class="AceCode" data-mode="c_cpp">//===============================================
void GRS232_Send_Char(char aChar) {
    char lData = aChar;
	if(lData == '\a') lData = 0x07;      //Alert
	else if(lData == '\b') lData = 0x08; //Backspace
	else if(lData == '\t') lData = 0x09; //Horizontal Tab
	else if(lData == '\r') lData = 0x0A; //Newline
	else if(lData == '\v') lData = 0x0B; //Vertical Tab
	else if(lData == '\f') lData = 0x0C; //Formfeed
	else if(lData == '\n') lData = 0x0D; //Carriage Return
	SBUF = lData;		
	while(TI == 0);		
	TI = 0;			
}
//===============================================</xmp></pre></div><br><h3 class="Title8 GTitle3">Simulation électrique</h3><br><span class="GColor1" style="color:lime;">Diode LED éteinte pendant 1s</span><div class="Img3 GImage"><img src="img/Communication_RS232.png" alt="img/Communication_RS232.png"></div><br><span class="GColor1" style="color:lime;">Diode LED allumée pendant 1s</span><div class="Img3 GImage"><img src="img/Communication_RS232_02.png" alt="img/Communication_RS232_02.png"></div><br><span class="GColor1" style="color:lime;">Communications RS232 (Temps écoulé)</span><div class="Img3 GImage"><img src="img/Communication_RS232_03.png" alt="img/Communication_RS232_03.png"></div><br><span class="GColor1" style="color:lime;">Forme d'onde (Les délais sont très précis)</span><div class="Img3 GImage"><img src="img/Communication_RS232_04.png" alt="img/Communication_RS232_04.png"></div></div></div></div></div><br>