<div class="Parallax GParallax1"><div class="Img Binary"><div class="Caption"><a href="#"><div class="Text">Quelques outils utiles<br></div></a></div></div><div class="Body2 Orange"><br>Le but de ce tutoriel est de vous présenter quelques <b>outils </b>utiles.<br>Produit par <b>Gérard KESSE</b>.<br><br><div class="Content0 GSummary1"><div class="Item4"><span class="Icon10 fa fa-book"></span><a class="Link4" href="#Introduction">Introduction</a></div><div class="Item4"><span class="Icon10 fa fa-book"></span><a class="Link4" href="#Keepass">Keepass</a></div><div class="Item4"><span class="Icon10 fa fa-book"></span><a class="Link4" href="#Oracle-Database">Oracle Database</a></div><div class="Item4"><span class="Icon10 fa fa-book"></span><a class="Link4" href="#Oracle-SQL-Developer">Oracle SQL Developer</a></div><div class="Item4"><span class="Icon10 fa fa-book"></span><a class="Link4" href="#OCILIB">OCILIB</a></div><div class="Item4"><span class="Icon10 fa fa-book"></span><a class="Link4" href="#Borland-C---Builder">Borland C++ Builder</a></div><div class="Item4"><span class="Icon10 fa fa-book"></span><a class="Link4" href="#CSV">CSV</a></div><div class="Item4"><span class="Icon10 fa fa-book"></span><a class="Link4" href="#FTP">FTP</a></div></div><br></div></div><br><div class="Content2 GTitle1"><div class="MainBlock2"><div class="Content"><h1 class="Title2 Center" id="Introduction"><a class="Link3" href="#">Introduction</a></h1><div class="Body3"><br>Un <b>outil</b> est un logiciel destiné à réaliser une tâche.<br><br><div class="Img3 GImage"><img src="/Tutoriels/Resources/ToolBox/img/b_toolbox.png" alt="/Tutoriels/Resources/ToolBox/img/b_toolbox.png"></div><br></div></div></div></div><br><div class="Content2 GTitle1"><div class="MainBlock2"><div class="Content"><h1 class="Title2 Center" id="Keepass"><a class="Link3" href="#">Keepass</a></h1><div class="Body3"><br><b>KeePass Password Safe </b>est un gestionnaire de mots de passe gratuit et open source principalement pour Windows . Il prend officiellement en charge les systèmes d'exploitation macOS et Linux via l'utilisation de Mono . De plus, il existe plusieurs ports non officiels pour les appareils Windows Phone , Android , iOS et BlackBerry . KeePass stocke les noms d'utilisateur, les mots de passe et d'autres champs, y compris les notes de forme libre et les pièces jointes, dans un fichier crypté . Ce fichier peut être protégé par n'importe quelle combinaison d'un mot de passe principal, d'un fichier de clé et des détails du compte Windows actuel. Par défaut, la base de données KeePass est stockée sur un système de fichiers local (par opposition au stockage en nuage ). KeePass prend en charge un certain nombre de plugins . Il dispose d'un générateur de mot de passe et d'une fonction de synchronisation, prend en charge l'authentification à deux facteurs et dispose d'un mode Secure Desktop . Il peut utiliser une fonction d'obscurcissement de type automatique à deux canaux pour offrir une protection supplémentaire contre les enregistreurs de frappe . KeePass peut importer à partir de plus de 30 autres gestionnaires de mots de passe les plus couramment utilisés.<br><br><div class="Content0 GSummary2"><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Keepass-Installer-l-environnement-Keepass-sous-Windows">Installer l'environnement Keepass sous Windows</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Keepass-Installer-une-nouvelle-langue">Installer une nouvelle langue</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Keepass-Modifier-la-langue">Modifier la langue</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Keepass-Modifier-les-options">Modifier les options</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Keepass-Creer-le-mot-de-passe-maitre">Créer le mot de passe maître</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Keepass-Demarrer-Keepass">Démarrer Keepass</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Keepass-Generer-un-mot-de-passe">Générer un mot de passe</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Keepass-Enregistrer-un-mot-de-passe-existant">Enregistrer un mot de passe existant</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Keepass-Exporter-les-mots-de-passe">Exporter les mots de passe</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Keepass-Importer-les-mots-de-passe">Importer les mots de passe</a></div></div><br><h2 class="Title7 GTitle2" id="Keepass-Installer-l-environnement-Keepass-sous-Windows"><a class="Link9" href="#Keepass">Installer l'environnement Keepass sous Windows</a></h2><br><h3 class="Title8 GTitle3">Télécharger Keepass</h3><br><a class="Link7 GLink1" style="color:lime;" target="_blank" href="https://keepass.info/download.html">https://keepass.info/download.html</a><br><br><b>KeePass-2.48.1-Setup.exe</b><br><br><h3 class="Title8 GTitle3">Installer Keepass</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="batchfile">KeePass-2.48.1-Setup.exe
Langue -&gt; Française
OK
Cocher -&gt; Je comprends et j'accepte les termes du contrat de licence
Suivant
Destination -&gt; C:\Program Files\KeePass Password Safe 2
Suivant
Suivant
Cocher -&gt; Associer Keepass avec l'extension de fichier .kdbx
Suivant
Installer
Cocher -&gt; Exécuter Keepass
Terminer
Check for Updates -&gt; Enable</pre></div></div><br><h2 class="Title7 GTitle2" id="Keepass-Installer-une-nouvelle-langue"><a class="Link9" href="#Keepass">Installer une nouvelle langue</a></h2><br><h3 class="Title8 GTitle3">Télécharger le traducteur Français</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="batchfile">View
Change Language
Get More Languages</pre></div></div><br><a class="Link7 GLink1" style="color:lime;" target="_blank" href="https://keepass.info/translations.html">https://keepass.info/translations.html</a><br><br>French<br>Ronan Plantec<br>v2.48+<br><br><b>KeePass-2.48-French-b.zip</b><br><br><h3 class="Title8 GTitle3">Extraire le traducteur Français</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="batchfile">KeePass-2.48-French-b.zip
Clic droit
Extraire vers KeePass-2.48-French-b\</pre></div></div><br><h3 class="Title8 GTitle3">Installer le traducteur Français</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="batchfile">Copier -&gt; KeePass-2.48-French-b\French.lngx
Coller -&gt; C:\Program Files\KeePass Password Safe 2\Languages</pre></div></div><br><h2 class="Title7 GTitle2" id="Keepass-Modifier-la-langue"><a class="Link9" href="#Keepass">Modifier la langue</a></h2><br><h3 class="Title8 GTitle3">Choisir la langue Française</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="batchfile">Keepass
View
Change Language
Installed Languages
French (Français)
Restart -&gt; Oui</pre></div></div><br><h2 class="Title7 GTitle2" id="Keepass-Modifier-les-options"><a class="Link9" href="#Keepass">Modifier les options</a></h2><br><h3 class="Title8 GTitle3">Modifier les options</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="batchfile">Keepass
Outils
Options
Cocher/Décocher -&gt; Verrouiller. 
Cocher/Décocher -&gt; Quitter...
Cocher/Décocher -&gt; Effacer...</pre></div></div><br><h2 class="Title7 GTitle2" id="Keepass-Creer-le-mot-de-passe-maitre"><a class="Link9" href="#Keepass">Créer le mot de passe maître</a></h2><br><h3 class="Title8 GTitle3">Créer le mot de passe maître</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="batchfile">Keepass
Fichier
Nouveau
Nouvelle base de données
OK
Nom du fichier -&gt; C:\Users\Admin\Documents\keepass_bdd.kdbx
Cocher -&gt; Mot de passe maître -&gt; xxxxxxxxxxxxxxxxxxxxx
Répéter -&gt; xxxxxxxxxxxxxxxxxxxxx
OK
Nom de la base de données -&gt; bdd_keepass
Nom de l'utilisateur par défaut -&gt; xxxxxx
OK
Feuille de secours -&gt; Imprimer</pre></div></div><br><h2 class="Title7 GTitle2" id="Keepass-Demarrer-Keepass"><a class="Link9" href="#Keepass">Démarrer Keepass</a></h2><br><h3 class="Title8 GTitle3">Démarrer Keepass</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="batchfile">Keepass
Cocher -&gt; Mot de passe maître -&gt; xxxxxx (produitpargerardkesse)
OK</pre></div></div><br><h2 class="Title7 GTitle2" id="Keepass-Generer-un-mot-de-passe"><a class="Link9" href="#Keepass">Générer un mot de passe</a></h2><br><h3 class="Title8 GTitle3">Générer un mot de passe</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="batchfile">Keepass
Entrée
Ajouter une entrée
Général
Titre -&gt; Votre titre
Nom d'utilisateur -&gt; xxxxxxxxxx
Générer un mot de passe
Ouvrir le générateur de mot de passe
Cocher -&gt; Générer en utilisant un jeu de caractères
Longueur dun mot de passe généré -&gt; Votre longueur (30)
Cocher -&gt; Vos choix
Inclure également les caractères suivants -&gt; Vos caractères
OK</pre></div></div><br><br><h2 class="Title7 GTitle2" id="Keepass-Enregistrer-un-mot-de-passe-existant"><a class="Link9" href="#Keepass">Enregistrer un mot de passe existant</a></h2><br><h3 class="Title8 GTitle3">Enregistrer un mot de passe existant</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="batchfile">Keepass
Entrée
Ajouter une entrée
Général
Titre -&gt; xxxxxx (ReadyDev)
Nom d'utilisateur -&gt; xxxxxx
Générer un mot de passe
Ouvrir le générateur de mot de passe
Cocher -&gt; Générer en utilisant un jeu de caractères
Longueur dun mot de passe généré -&gt; Votre longueur (30)
Cocher -&gt; Vos choix
Inclure également les caractères suivants -&gt; Vos caractères
OK</pre></div></div><br><h2 class="Title7 GTitle2" id="Keepass-Exporter-les-mots-de-passe"><a class="Link9" href="#Keepass">Exporter les mots de passe</a></h2><br><h3 class="Title8 GTitle3">Exporter les mots de passe</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="batchfile">Keepass
Fichier
Enregistrer sous
Enregistrer sous le fichier
Nom du fichier -&gt; C:\Users\Admin\Documents\keepass_bdd.kdbx
Enregistrer</pre></div></div><br><h2 class="Title7 GTitle2" id="Keepass-Importer-les-mots-de-passe"><a class="Link9" href="#Keepass">Importer les mots de passe</a></h2><br><h3 class="Title8 GTitle3">Importer les mots de passe</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="batchfile">Keepass
Fichier
Ouvrir
Ouvrir un fichier
Nom du fichier -&gt; C:\Users\Admin\Documents\keepass_bdd.kdbx
Ouvrir
Cocher -&gt; Mot de passe maître -&gt; xxxxxx (produitpargerardkesse)
OK</pre></div></div><br></div></div></div></div><br><div class="Content2 GTitle1"><div class="MainBlock2"><div class="Content"><h1 class="Title2 Center" id="Oracle-Database"><a class="Link3" href="#">Oracle Database</a></h1><div class="Body3"><br><b>Oracle Database</b> (communément appelé Oracle DBMS ou simplement Oracle ) est un système de gestion de base de données multi-modèle produit et commercialisé par Oracle Corporation . Il s'agit d'une base de données couramment utilisée pour exécuter des charges de travail de base de données de traitement des transactions en ligne (OLTP), d' entreposage de données (DW) et mixtes (OLTP et DW). Oracle Database est disponible par plusieurs fournisseurs de services sur site , sur le cloud ou en tant qu'installation cloud hybride. Il peut être exécuté sur des serveurs tiers ainsi que sur du matériel Oracle ( Exadata on-prem, sur Oracle Cloud ou chez Cloud at Customer).<br><br><div class="Content0 GSummary2"><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Documentation-sur-Oracle-PL-SQL">Documentation sur Oracle PL/SQL</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Installer-l-environnement-Oracle-Database-sous-Windonws">Installer l'environnement Oracle Database sous Windonws</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Executer-une-requete-a-partir-d-un-fichier">Exécuter une requête à partir d'un fichier</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Afficher-un-message">Afficher un message</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Creer-un-commentaire-simple">Créer un commentaire simple</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Creer-un-commentaire-multiple">Créer un commentaire multiple</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Declarer-une-variable">Déclarer une variable</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Afficher-une-variable">Afficher une variable</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Initialiser-une-variable-lors-de-la-declaration--1-">Initialiser une variable lors de la déclaration (1)</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Initialiser-une-variable-lors-de-la-declaration--2-">Initialiser une variable lors de la déclaration (2)</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Creer-une-variable-constante">Créer une variable constante</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Creer-un-sous-type">Créer un sous-type</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Creer-une-declaration-contrainte">Créer une déclaration contrainte</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Echapper-un-caractere">Echapper un caractère</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Formater-une-chaine">Formater une chaine</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Realiser-des-operations-arithmetiques">Réaliser des opérations arithmétiques</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Realiser-des-operations-de-comparaison">Réaliser des opérations de comparaison</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Realiser-des-operations-logiques">Réaliser des opérations logiques</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Creer-une-condition-if">Créer une condition if</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Creer-une-condition-if-else">Créer une condition if else</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Creer-une-condition-else-if">Créer une condition else if</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Creer-une-condition-case-when">Créer une condition case when</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Creer-une-boucle-loop">Créer une boucle loop</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Creer-une-boucle-while">Créer une boucle while</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Creer-une-boucle-for">Créer une boucle for</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Creer-une-boucle-for-inverse">Créer une boucle for inversé</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Realiser-des-operations-sur-les-chaines">Réaliser des opérations sur les chaines</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Creer-un-tableau-varray">Créer un tableau varray</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Creer-une-procedure-stockee">Créer une procédure stockée</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Executer-une-procedure-stockee">Exécuter une procédure stockée</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Appeler-une-procedure-stockee">Appeler une procédure stockée</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Supprimer-une-procedure-stockee">Supprimer une procédure stockée</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Creer-une-procedure-non-stockee">Créer une procédure non stockée</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Creer-une-procedure-avec-des-entrees-et-des-sorties">Créer une procédure avec des entrées et des sorties</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Creer-une-procedure-avec-un-passage-par-reference">Créer une procédure avec un passage par référence</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Appeler-une-procedure-en-notation-positionnelle">Appeler une procédure en notation positionnelle</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Appeler-une-procedure-en-notation-nommee">Appeler une procédure en notation nommée</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Appeler-une-procedure-en-notation-mixte">Appeler une procédure en notation mixte</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Creer-une-fonction-stockee">Créer une fonction stockée</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Supprimer-une-fonction-stockee">Supprimer une fonction stockée</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Appeler-une-fonction-stockee">Appeler une fonction stockée</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Creer-une-table">Créer une table</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Inserer-des-donnees-dans-une-table">Insérer des données dans une table</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Afficher-les-donnees-d-une-table">Afficher les données d'une table</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Ajouter-une-nouvelle-colonne-a-une-table">Ajouter une nouvelle colonne à une table</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Creer-une-table-a-partir-d-une-autre-une-table">Créer une table à partir d'une autre une table</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Supprimer-une-table">Supprimer une table</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Renommer-une-table">Renommer une table</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Supprimer-une-colonne-dans-une-table">Supprimer une colonne dans une table</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Package">Package</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Curseur">Curseur</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Enregistrement">Enregistrement</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Exception">Exception</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Declencheur">Déclencheur</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Collection">Collection</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Transaction">Transaction</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-Database-Date-et-heure">Date et heure</a></div></div><br><h2 class="Title7 GTitle2" id="Oracle-Database-Documentation-sur-Oracle-PL-SQL"><a class="Link9" href="#Oracle-Database">Documentation sur Oracle PL/SQL</a></h2><br><a class="Link7 GLink1" style="color:lime;" target="_blank" href="https://www.techonthenet.com/oracle/index.php">https://www.techonthenet.com/oracle/index.php</a><br><br><h2 class="Title7 GTitle2" id="Oracle-Database-Installer-l-environnement-Oracle-Database-sous-Windonws"><a class="Link9" href="#Oracle-Database">Installer l'environnement Oracle Database sous Windonws</a></h2><br><h3 class="Title8 GTitle3">Télécharger Oracle Database</h3><br><a class="Link7 GLink1" style="color:lime;" target="_blank" href="https://www.oracle.com/database/technologies/xe-downloads.html">https://www.oracle.com/database/technologies/xe-downloads.html</a><br><br><b>OracleXE184_Win64.zip</b><br><br><h3 class="Title8 GTitle3">Extraire Oracle Database</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="batchfile">OracleXE184_Win64.zip
Clic droit
Extraire vers OracleXE184_Win64\</pre></div></div><br><h3 class="Title8 GTitle3">Installer Oracle Database</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="batchfile">OracleXE184_Win64
Setup.exe
Next
Cocher -&gt; I accept the terms in the license agreement
Next
Install Oracle Database -&gt; C:\app\Admin\product\18.0.0\
Next
Database Password -&gt; xxxxxxxxxx
Confirm Database Password -&gt; xxxxxxxxxx
Next
Destination Folder -&gt; C:\app\Admin\product\18.0.0\
Oracle Home -&gt; C:\app\Admin\product\18.0.0\dbhomeXE\
Oracle Base -&gt; C:\app\Admin\product\18.0.0\
Install
Multitenant container database -&gt; localhost:1521
Pluggable database -&gt; localhost:1521/XEPDB1
EM Express URL -&gt; https://localhost:5500/em
Finish</pre></div></div><br><h3 class="Title8 GTitle3">Démarrer la connexion</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">sqlplus / as sysdba</pre></div></div><br><h3 class="Title8 GTitle3">Vérifier la version</h3><br>select * from v$version;<br><br><h3 class="Title8 GTitle3">Vérifier le mode d'ouverture</h3><br>select name, open_mode from v$pdbs;<br><br><h3 class="Title8 GTitle3">Quitter</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">exit;</pre></div></div><br><h2 class="Title7 GTitle2" id="Oracle-Database-Executer-une-requete-a-partir-d-un-fichier"><a class="Link9" href="#Oracle-Database">Exécuter une requête à partir d'un fichier</a></h2><br><h3 class="Title8 GTitle3">Créer le script (script.sql)</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">select * from v$version;</pre></div></div><br><h3 class="Title8 GTitle3">Démarrer la connexion</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">sqlplus / as sysdba</pre></div></div><br><h3 class="Title8 GTitle3">Exécuter le script</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">@script.sql</pre></div></div><br><h2 class="Title7 GTitle2" id="Oracle-Database-Programme-minimal"><a class="Link9" href="#Oracle-Database">Programme minimal</a></h2><br>PL/SQL est un langage structuré par blocs ; cela signifie que les <b>programmes</b> PL/SQL sont divisés et écrits en blocs de code logiques. Chaque bloc se compose de trois sous-parties : le bloc de déclaration des variables, le bloc d'exécution des commandes et le bloc de gestion des erreurs. Chaque instruction PL/SQL se termine par un point-virgule (;). Les blocs PL/SQL peuvent être imbriqués dans d'autres blocs PL/SQL à l'aide de <b>BEGIN </b>et <b>END</b>. Seul le bloc d'exécution des commandes est obligatoire.<br><br><h3 class="Title8 GTitle3">Créer un programme minimal complet</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare 
    -- declaration des variables
begin 
    -- execution des commandes
exception 
    -- gestion des erreurs
end;
/
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Créer un programme minimal simplifié</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
begin 
    -- execution des commandes
end;
/
-- ==============================================</pre></div></div><br><h2 class="Title7 GTitle2" id="Oracle-Database-Affichage-de-message"><a class="Link9" href="#Oracle-Database">Affichage de message</a></h2><br>Le package <b>DBMS_OUTPUT </b>vous permet d'envoyer des messages à partir de procédures stockées et de packages. Le package est particulièrement utile pour afficher les informations de débogage PL/SQL.<br><br><h3 class="Title8 GTitle3">Afficher un message simple<br></h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
set serveroutput on;
-- ==============================================
begin 
    dbms_output.put_line('mon_message'); 
end;
/
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Afficher le contenu d'une variable<br></h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
set serveroutput on;
-- ==============================================
begin 
    dbms_output.put_line('ma_variable : ' || ma_variable); 
end;
/
-- ==============================================</pre></div></div><br><h2 class="Title7 GTitle2" id="Oracle-Database-Commentaire"><a class="Link9" href="#Oracle-Database">Commentaire</a></h2><br><h3 class="Title8 GTitle3">Créer un commentaire sur une ligne</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
-- voici mon commentaire sur une ligne
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Créer un commentaire sur plusieurs lignes</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
/*
 * voici mon commentaire sur plusieurs lignes
 * voici mon commentaire sur plusieurs lignes
 * voici mon commentaire sur plusieurs lignes
 */
-- ==============================================</pre></div></div><br><h2 class="Title7 GTitle2" id="Oracle-Database-Variable"><a class="Link9" href="#Oracle-Database">Variable</a></h2><br>Une <b>variable </b>n'est rien d'autre qu'un nom donné à une zone de stockage que nos programmes peuvent manipuler. Chaque variable en PL/SQL a un type de données spécifique, qui détermine la taille et la disposition de la mémoire de la variable ; la plage de valeurs qui peuvent être stockées dans cette mémoire et l'ensemble des opérations qui peuvent être appliquées à la variable. PL/SQL permet l'imbrication de blocs, c'est-à-dire que chaque bloc de programme peut contenir un autre bloc interne. Si une variable est déclarée dans un bloc interne, elle n'est pas accessible au bloc externe. Cependant, si une variable est déclarée et accessible à un bloc externe, elle est également accessible à tous les blocs internes imbriqués. Il existe deux types de portée variable : les variables locales et les variables globales. Les variables locales sont des variables déclarées dans un bloc interne et non accessibles aux blocs externes. Les variables globales sont des variables déclarées dans le bloc le plus à l'extérieur ou dans un package.<br><br><h3 class="Title8 GTitle3">Déclarer une variable<br></h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration des variables
    ma_variable number; 
begin 
    -- execution des commandes
end;
/
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Initialiser une variable à la déclaration</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration des variables
    ma_variable_1 number := 10; 
    ma_variable_2 number default 20; 
begin 
    -- execution des commandes
end;
/
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Affecter une variable</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration des variable
    ma_variable number; 
begin 
    -- affectation des variables
    ma_variable := 10;
end;
/
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Créer une variable constante</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration des variables
    ma_constante constant number := 10; 
begin 
    -- execution des commandes
end;
/
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Créer des variables locales et globales</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration des variable globales
    ma_variable_globale number := 10; 
begin 
    -- execution des commandes globales
    declare
        -- declaration des variable locales
        ma_variable_locale number := 20;
    begin
        -- execution des commandes locales
    end;
end;
/
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Affecter le résultat d'une requête à une varibale</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration des variables
    c_col_1 ma_table.col_1%type := donnee_1; 
    c_col_2 ma_table.col_2%type; 
    c_col_3 ma_table.col_3%type; 
begin 
    -- affectation des variables
    select col_1, col_2, col_3
    into c_col_1, c_col_2, c_col_3
    from ma_table
    where col_4 = donnee_4
    -- utilisation des variables
    -- c_col_1
    -- c_col_2
    -- c_col_3
end;
/
-- ==============================================</pre></div></div><br><h2 class="Title7 GTitle2" id="Oracle-Database-Opearateur"><a class="Link9" href="#Oracle-Database">Opéarateur</a></h2><br>Un <b>opérateur </b>est un symbole qui indique au compilateur d'effectuer une manipulation mathématique ou logique spécifique. Le langage PL/SQL est riche en opérateurs intégrés et fournit les types d'opérateurs suivants : les opérateurs arithmétiques, les opérateurs relationnels, les opérateurs de comparaison, les opérateurs logiques, les opérateurs de chaîne. Les opérateurs relationnels comparent deux expressions ou valeurs et renvoient un résultat booléen.<br><br><h3 class="Title8 GTitle3">Réaliser des opérations arithmétiques</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration des variables
    a number := 22; 
    b number := 7;
    mon_addition number;
    ma_soustraction number;
    ma_multiplication number;
    ma_division number;
    ma_puissance number;
begin 
    -- realisation des operations arithmetiques
    mon_addition := a + b;
    ma_soustraction := a - b;
    ma_multiplication := a * b;
    ma_division := a / b;
    ma_puissance := a ** b;
end;
/
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Réaliser des opérations relationnelles</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration des variables
    a number := 22; 
    b number := 7;
    est_egal boolean;
    est_different_1 boolean;
    est_different_2 boolean;
    est_different_3 boolean;
    est_superieur boolean;
    est_inferieur boolean;
    est_superieur_egal boolean;
    est_inferieur_egal boolean;
begin 
    -- realisation des operations relationnelles
    est_egal := (a = b);
    est_different_1 := (a != b);
    est_different_2 := (a &lt;&gt; b);
    est_different_3 := (a ~= b);
    est_superieur := (a &gt; b);
    est_inferieur := (a &lt; b);
    est_superieur_egal := (a &gt;= b);
    est_inferieur_egal := (a &lt;= b);
end;
/
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Réaliser des opérations de comparaison</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration des variables
    a number := 22; 
    b number := 7;
    ma_chaine varchar2(10);
    mon_nombre number;
    mon_element  varchar2(20);
    ma_variable  varchar2(20);
begin 
    -- like
    if ma_chaine like 'mon_motif%' then
        -- code si chaine correspond a motif
    end if;
    -- between
    if mon_nombre between a and b then
        -- code si nombre appartient [a ; b]
    end if;
    -- in
    if mon_element in (item_1, item_2, item_3) then
        -- code si nombre appartient ensemble
    end if;
    -- is null
    if ma_variable is null then
        -- code si variable nulle
    end if;
end;
/
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Réaliser des opérations logiques</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration des variables
    ma_condition_1 boolean;
    ma_condition_2 boolean;
begin 
    -- and
    if ma_condition_1 and ma_condition_1 then
        -- code si la condition_1 et la condition_2 sont varies
    end if;
    -- or
    if ma_condition_1 or ma_condition_1 then
        -- code si la condition_1 ou la condition_2 est varie
    end if;
    -- not
    if not ma_condition_1 then
        -- code si la condition_1 est fausse
    end if;
end;
/
-- ==============================================</pre></div></div><br><h2 class="Title7 GTitle2" id="Oracle-Database-Condition"><a class="Link9" href="#Oracle-Database">Condition</a></h2><br>Les structures de prise de décision exigent que le programmeur spécifie une ou plusieurs <b>conditions </b>à évaluer ou à tester par le programme, ainsi qu'une ou plusieurs instructions à exécuter si la condition est déterminée comme étant vraie, et facultativement, d'autres instructions à exécuter si le condition est considérée comme fausse.<br><br><h3 class="Title8 GTitle3">Créer une condition if</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration des variables
    a number := 20;
    b number := 10;
begin 
    if a &gt; b then
        -- code si condition est vraie
    end if;
end;
/
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Créer une condition if else</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration des variables
    a number := 20;
    b number := 10;
begin 
    if a &gt; b then
        -- code si condition est vraie
    else
        -- code dans le cas contraire
    end if;
end;
/
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Créer une condition elsif</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration des variables
    a number := 20;
    b number := 10;
begin 
    if a &gt; b then
        -- code si condition_1 est vraie
    elsif a = b then
        -- code sinon si condition_2 est vraie
    else
        -- code dans le cas contraire
    end if;
end;
/
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Créer une condition case when</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration des variables
    ma_variable integer := 3;
begin 
    case ma_variable
        when 1 then
            -- code si condition_1 vraie
        when 2 then
            -- code si condition_2 vraie
        when 3 then
            -- code si condition_3 vraie
        else
            -- code dans le cas contraire
    end case;
end;
/
-- ==============================================</pre></div></div><br><h2 class="Title7 GTitle2" id="Oracle-Database-Boucle"><a class="Link9" href="#Oracle-Database">Boucle</a></h2><br>Il peut arriver que vous deviez exécuter un bloc de code plusieurs fois. En général, les instructions sont exécutées séquentiellement : la première instruction d'une fonction est exécutée en premier, suivie de la seconde, et ainsi de suite. Les langages de programmation fournissent diverses structures de contrôle qui permettent des chemins d'exécution plus complexes. Une instruction de <b>boucle </b>nous permet d'exécuter une instruction ou un groupe d'instructions plusieurs fois.<br><br><h3 class="Title8 GTitle3">Créer une boucle loop</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration des variables
    mon_compteur integer := 0;
begin 
    loop
        -- condition de sortie
        if mon_compteur = 10 then exit; end if;
        --
        -- code a executer en boucle
        --
        -- incrementation du compteur
        mon_compteur := mon_compteur + 1;
    end loop;
end;
/
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Créer une boucle while</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration des variables
    mon_compteur integer := 0;
begin 
    while mon_compteur &lt; 10 loop
        --
        -- code a executer en boucle
        --
        -- incrementation du compteur
        mon_compteur := mon_compteur + 1;
    end loop;
end;
/
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Créer une boucle for</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration des variables
begin 
    for i in 1..10 loop
        --
        -- code a executer en boucle
        --
    end loop;
end;
/
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Créer une boucle for inversé</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration des variables
begin 
    for i in reverse 1..10 loop
        --
        -- code a executer en boucle
        --
    end loop;
end;
/
-- ==============================================</pre></div></div><br><h2 class="Title7 GTitle2" id="Oracle-Database-Chaine"><a class="Link9" href="#Oracle-Database">Chaîne</a></h2><br>La <b>chaîne </b>en PL/SQL est en fait une séquence de caractères avec une spécification de taille facultative. Les caractères peuvent être des chiffres, des lettres, des blancs, des caractères spéciaux ou une combinaison de tous. PL/SQL propose trois types de chaînes : les chaînes de longueur fixe,&nbsp; les chaînes de longueur variable et les objets de grande taille (CLOB). Dans les chaînes de longueur fixe, les programmeurs spécifient la longueur lors de la déclaration de la chaîne. La chaîne est complétée à droite avec des espaces jusqu'à la longueur spécifiée. ans les chaînes de longueur variable, une longueur maximale jusqu'à 32 767, pour la chaîne est spécifiée et aucun remplissage n'a lieu. Dans les objets de grande taille (CLOB), Il s'agit de chaînes de longueur variable pouvant atteindre 128 téraoctets.<br><br><h3 class="Title8 GTitle3">Déclarer une chaîne</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration des variables
    ma_chaine_fixe varchar2(10);
    ma_chaine_variable varchar2;
    ma_chaine_clob clob;
begin 
    -- utilisation des chaines
    -- ma_chaine_fixe
    -- ma_chaine_variable
    -- ma_chaine_clob
end;
/
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Liste des fonctions associées à une chaîne</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="txt">Nom                             | Description
--------------------------------+----------------------------------------
ASCII(x);                       | Renvoie la valeur ASCII du caractère x.	
--------------------------------+----------------------------------------
CHR(x);                         | Renvoie le caractère avec la valeur ASCII de x.
--------------------------------+----------------------------------------
CONCAT(x, y);                   | Concatène les chaînes x et y et renvoie la chaîne ajoutée.
--------------------------------+----------------------------------------
INITCAP(x);                     | Convertit la lettre initiale de chaque mot de x en majuscule et renvoie cette chaîne.	
--------------------------------+----------------------------------------
INSTR(x, find_string            | Recherche find_string dans x et renvoie la position à laquelle il se produit.	
[, start] [, occurrence]);      |
--------------------------------+----------------------------------------
INSTRB(x);                      | Renvoie l'emplacement d'une chaîne dans une autre chaîne, mais renvoie la valeur en octets.	
--------------------------------+----------------------------------------
LENGTH(x);                      | Renvoie le nombre de caractères dans x.	
--------------------------------+----------------------------------------
LENGTHB(x);                     | Renvoie la longueur d'une chaîne de caractères en octets pour un jeu de caractères à un octet.	
--------------------------------+----------------------------------------
LOWER(x);                       | Convertit les lettres de x en minuscules et renvoie cette chaîne.	
--------------------------------+----------------------------------------
LPAD(x, width [, pad_string]) ; | Remplit x avec des espaces à gauche, pour amener la longueur totale de la chaîne jusqu'à la largeur des caractères.	
--------------------------------+----------------------------------------
LTRIM(x [, trim_string]);       | Coupe les caractères à partir de la gauche de x .
--------------------------------+----------------------------------------
NANVL(x, valeur);               | Renvoie la valeur si x correspond à la valeur spéciale NaN (pas un nombre), sinon x est renvoyé.
--------------------------------+----------------------------------------
NLS_INITCAP(x);                 | Identique à la fonction INITCAP sauf qu'elle peut utiliser une méthode de tri différente comme spécifié par NLSSORT.
--------------------------------+----------------------------------------
NLS_LOWER(x) ;                  | Identique à la fonction LOWER, sauf qu'elle peut utiliser une méthode de tri différente comme spécifié par NLSSORT.
--------------------------------+----------------------------------------
NLS_UPPER(x);                   | Identique à la fonction UPPER, sauf qu'elle peut utiliser une méthode de tri différente comme spécifié par NLSSORT.
--------------------------------+----------------------------------------
NLSSORT(x);                     | Modifie la méthode de tri des caractères. Doit être spécifié avant toute fonction NLS ; sinon, le tri par défaut sera utilisé.
--------------------------------+----------------------------------------
NVL(x, valeur);                 | Renvoie la valeur si x est nul ; sinon, x est renvoyé.
--------------------------------+----------------------------------------
NVL2(x, valeur1, valeur2) ;     | Renvoie value1 si x n'est pas nul ; si x est nul, value2 est renvoyé.
--------------------------------+----------------------------------------
REPLACE(x, search_string,       | Recherche x pour search_string et le remplace par replace_string.
replace_string);                |
--------------------------------+----------------------------------------
RPAD(x, width [, pad_string]);  | Tampons x vers la droite.
--------------------------------+----------------------------------------
RTRIM(x [, trim_string]);       | Coupe x à partir de la droite.
--------------------------------+----------------------------------------
SOUNDEX(x) ;                    | Renvoie une chaîne contenant la représentation phonétique de x .
--------------------------------+----------------------------------------
SUBSTR(x, start [, length]);    | Renvoie une sous-chaîne de x qui commence à la position spécifiée par start. Une longueur facultative pour la sous-chaîne peut être fournie.
--------------------------------+----------------------------------------
SUBSTRB(x);                     | Identique à SUBSTR sauf que les paramètres sont exprimés en octets au lieu de caractères pour les systèmes de caractères à un octet.
--------------------------------+----------------------------------------
TRIM([trim_char FROM) x);       | Coupe les caractères à gauche et à droite de x .
--------------------------------+----------------------------------------
UPPER(x);                       | Convertit les lettres de x en majuscules et renvoie cette chaîne.
--------------------------------+----------------------------------------</pre></div></div><br><h2 class="Title7 GTitle2" id="Oracle-Database-Tableau"><a class="Link9" href="#Oracle-Database">Tableau</a></h2><br>Le langage de programmation PL/SQL fournit une structure de données appelée <b>VARRAY </b>, qui peut stocker une collection séquentielle de taille fixe d'éléments du même type. Un varray est utilisé pour stocker une collection ordonnée de données, mais il est souvent préférable de considérer un tableau comme une collection de variables du même type. Tous les varrays sont constitués d'emplacements de mémoire contigus. L'adresse la plus basse correspond au premier élément et l'adresse la plus élevée au dernier élément. <br><br><h3 class="Title8 GTitle3">Créer un tableau varray (hors bloc)<br></h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="txt">-- ==============================================
create or replace type mon_type_varray as varray(3) of varchar2(10);
/
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Créer un tableau varray (dans un bloc)</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration des collections
    type mon_type_collection is 
        varray(3) varchar2(10);
    -- declaration des variables
    ma_collection mon_type_collection;
begin 
    -- chargement des collections
    ma_collection := mon_type_collection('donnee_1', 'donnee_2', 'donnee_3');
    -- utilisation des collections 
    for i in 1 .. ma_collection.count loop
        -- utilisation des donnees
        -- ma_collection(i)
    end loop;
end;
/
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Etendre un tableau varray</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration du curseur
    cursor mon_curseur is
        select col_1 from ma_table;
    -- declaration du types de la collection
    type mon_type_collection is 
        varray(6) of ma_table.col_1%type;
    -- declaration de la collection
    ma_collection mon_type_collection := mon_type_collection();
    -- declaration des variables
    mon_compteur integer := 0;
begin 
    -- chargement de la collection
    for mon_element in mon_curseur loop
        mon_compteur := mon_compteur + 1;
        ma_collection.extend;
        ma_collection(mon_compteur) := mon_element;
    -- utilisation de la collection
    for i in 1 .. ma_collection.count loop
        -- utilisation des donnees
        -- ma_collection(i)
    end loop;
end;
/
-- ==============================================</pre></div></div><br><h2 class="Title7 GTitle2" id="Oracle-Database-Procedure"><a class="Link9" href="#Oracle-Database">Procédure</a></h2><br>Une <b>procédure </b>est un ensemble d'instructions SQL pré-compilées, stockées dans une base de données et exécutées sur demande par le SGBD qui manipule la base de données. Les procédures peuvent être lancées par un utilisateur, un administrateur DBA ou encore de façon automatique par un événement déclencheur (trigger). Les procédures ne renvoient pas de valeur directement pour effectuer une action. Les paramètres réels peuvent être transmis à une procédure de trois manières : en notation positionnelle, en notation nommée ou en notation mixte. En <b>notation positionnelle</b>, le premier paramètre réel se substitue au premier paramètre formel ; le deuxième paramètre réel se substitue au deuxième paramètre formel, et ainsi de suite. En <b>notation nommée</b>, le paramètre réel est associé au paramètre formel à l'aide du symbole flèche ( =&gt; ) . En <b>notation mixte</b>, vous pouvez mélanger les deux notations dans l'appel de procédure ; cependant, la notation positionnelle doit précéder la notation nommée<br><br><h3 class="Title8 GTitle3">Créer une procédure</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
create or replace procedure ma_procedure as
begin
    -- code de la procedure
end;
/
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Exécuter une procédure</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
execute ma_procedure;
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Appeler une procédure<br></h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
begin
    ma_procedure;
end;
/
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Supprimer une procédure</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
drop procedure ma_procedure;
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Créer une procédure avec des entrées et des sorties</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration des variables
    c_in_1 number := 10;
    c_out_1 number;
procedure ma_procedure(in_1 in number, out_1 out number) is
begin
    -- utilisation des arguments
    -- out_1 = mon_calcul(in_1)
end;
begin
    -- utilisation de la procedure
    ma_procedure(c_in_1, c_out_1);
    -- utilisation de la sortie
    -- c_out_1
end;
/
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Créer une procédure avec un passage par référence</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration des variables
    c_ref_1 number := 10;
procedure ma_procedure(ref_1 in out number) is
begin
    -- utilisation des arguments
    -- ref_1 = mon_calcul(ref_1)
end;
begin
    -- utilisation de la procedure
    ma_procedure(c_ref_1);
    -- utilisation de la reference
    -- c_ref_1
end;
/
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Appeler une procédure en notation positionnelle</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration des variables
    c_in_1 number := 10;
    c_out_1 number;
procedure ma_procedure(in_1 in number, out_1 out number) is
begin
    -- utilisation des arguments
    -- out_1 = mon_calcul(in_1)
end;
begin
    -- utilisation de la procedure
    -- en notation positionnelle
    ma_procedure(c_in_1, c_out_1);
    -- utilisation de la sortie
    -- c_out_1
end;
/
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Appeler une procédure en notation nommée</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration des variables
    c_in_1 number := 10;
    c_out_1 number;
procedure ma_procedure(in_1 in number, out_1 out number) is
begin
    -- utilisation des arguments
    -- out_1 = mon_calcul(in_1)
end;
begin
    -- utilisation de la procedure
    -- en notation nommée
    ma_procedure(in_1 =&gt; c_in_1, out_1 =&gt; c_out_1);
    -- utilisation de la sortie
    -- c_out_1
end;
/
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Appeler une procédure en notation mixte</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration des variables
    c_in_1 number := 10;
    c_out_1 number;
procedure ma_procedure(in_1 in number, out_1 out number) is
begin
    -- utilisation des arguments
    -- out_1 = mon_calcul(in_1)
end;
begin
    -- utilisation de la procedure
    -- en notation mixte
    ma_procedure(c_in_1, out_1 =&gt; c_out_1);
    -- utilisation de la sortie
    -- c_out_1
end;
/
-- ==============================================</pre></div></div><br><h2 class="Title7 GTitle2" id="Oracle-Database-Fonction"><a class="Link9" href="#Oracle-Database">Fonction</a></h2><br>Une <b>fonction </b>est un ensemble d'instructions SQL pré-compilées, stockées dans une base de données et exécutées sur demande par le SGBD qui manipule la base de données. Les fonctions peuvent être lancées par un utilisateur, un administrateur DBA ou encore de façon automatique par un événement déclencheur (trigger). Les fonctions renvoient une seule valeur obligatoirement. Elles sont principalement utilisées pour calculer et renvoyer une valeur. Une fonction récursive est une fonction qui s'appelle lui-même.<br><br><h3 class="Title8 GTitle3">Créer une fonction</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
create or replace function ma_fonction
return number is
    -- declaration des variables
    c_count number;
begin
    -- calcul de la valeur de retout
    select count(*) into c_count
    from ma_table;
    -- valeur de retour
    return c_count;
end;
/
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Supprimer une fonction</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
drop function ma_fonction;
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Appeler une fonction</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare     
    -- declaration des variables
    c_count number;
begin     
    -- utilisation de la fonction
    c_count := ma_fonction;
    -- utilisation de la valeur de retour
    -- c_count
end; 
/
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Créer une fonction récursive</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare     
    -- declaration des variables globales
    c_x number := 10;
    c_f number;
function ma_factorielle(x number)
return number is
    -- declaration des variables locales
    f number;
begin     
    -- condition de sortie
    if x = 0 then
        f := 1;
    -- appel recursive
    else
        f := x * ma_factorielle(x - 1);
    end if;
    -- valeur de retour
    return f;
end;
begin     
    -- utilisation de la fonction
    c_f := ma_factorielle(c_x);
    -- utilisation de la valeur de retour
    -- c_f
end; 
/
-- ==============================================</pre></div></div><br><h2 class="Title7 GTitle2" id="Oracle-Database-Table"><a class="Link9" href="#Oracle-Database">Table</a></h2><br>Une <b>table </b>est un ensemble de données associées conservées sous forme de table dans une base de données . Il se compose de colonnes et de lignes . Dans les bases de données relationnelles , et les bases de données à fichiers plats , une table est un ensemble d'éléments de données (valeurs) utilisant un modèle de colonnes verticales (identifiables par leur nom) et de lignes horizontales ,la cellule étant l'unité d'intersection d'une ligne et d'une colonne. Un tableau a un nombre spécifié de colonnes, mais peut avoir n'importe quel nombre de lignes. Chaque ligne est identifiée par une ou plusieurs valeurs apparaissant dans un sous-ensemble de colonnes particulier. Un choix spécifique de colonnes qui identifient de manière unique les lignes est appelé clé primaire .<br><br><h3 class="Title8 GTitle3">Créer une table</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
create table ma_table ( 
col_1 varchar2(50),
col_2 varchar2(50),
col_3 varchar2(50)
);
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Insérer des données dans une table</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
insert into ma_table (col_1, col_2, col_3)
values ('donnee_1', 'donnee_2', 'donnee_3');
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Afficher les données d'une table</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
select col_1, col_2, col_3
from ma_table;
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Afficher les données d'une table (taille des colonnes)</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
column col_1 format a10;
column col_2 format a20;
column col_3 format a30;
-- ==============================================
select col_1, col_2, col_3
from ma_table;
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Ajouter une nouvelle colonne à une table</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
alter table ma_table
add col_4 char(1) default '0';
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Créer une table à partir d'une autre une table</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
create table ma_table_2 as
select col_1, col_2, col_3 
from ma_table_1;
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Supprimer une table</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
drop table users;
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Renommer une table</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
alter table ma_table_1
rename to ma_table_2;
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Supprimer une colonne dans une table</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
alter table ma_table
drop column col_1;
-- ==============================================</pre></div></div><br><h2 class="Title7 GTitle2" id="Oracle-Database-Package"><a class="Link9" href="#Oracle-Database">Package</a></h2><br>Les <b>packages </b>sont des objets de schéma qui regroupent des types, des variables et des sous-programmes PL/SQL logiquement liés. Un package aura deux parties obligatoires : la spécification de l'emballage et le corps ou la définition du package. Le corps du package contient les codes des différentes méthodes déclarées dans la spécification du package et d'autres déclarations privées, qui sont masquées du code à l'extérieur du package.<br><br><h3 class="Title8 GTitle3">Créer un package</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
create package pkg_fnc_hello as
    function fnc_hello return varchar2;
end pkg_fnc_hello;
/
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Vérifier l'existence d'un package</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
select count(*)
from user_objects
where object_name = upper('pkg_fnc_hello')
and object_type = upper('package');
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Supprimer un package</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
drop package pkg_fnc_hello;
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Créer le corps du package</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
create or replace package body pkg_fnc_hello as
    function fnc_hello return varchar2 is 
    begin
        return 'Bonjour tout le monde';
    end fnc_hello;
end pkg_fnc_hello;
/
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Appeler un package</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
begin 
    dbms_output.put_line(pkg_fnc_hello.fnc_hello); 
end;
/
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Créer une surcharge de fonctions</h3><br>Création du package<br><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
create package pkg_fnc_hello as
    function fnc_hello return varchar2;
    function fnc_hello(name in varchar2) return varchar2;
end pkg_fnc_hello;
/
-- ==============================================</pre></div></div><br>Création du corps du package<br><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
create or replace package body pkg_fnc_hello as
    function fnc_hello return varchar2 is 
    begin
        return 'Bonjour tout le monde';
    end fnc_hello;
    -- ==============================================
    function fnc_hello(name in varchar2) return varchar2 is 
    begin
        return 'Bonjour ' || name;
    end fnc_hello;
end pkg_fnc_hello;
/
-- ==============================================</pre></div></div><br>Appel des fonctions<br><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
begin 
    dbms_output.put_line(pkg_fnc_hello.fnc_hello); 
    dbms_output.put_line(pkg_fnc_hello.fnc_hello('Gerard KESSE')); 
end;
/
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Créer une surcharge de procedures</h3><br>Création du package<br><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
create package pkg_prc_hello as
    procedure prc_hello;
    procedure prc_hello(name in varchar2);
end pkg_prc_hello;
/
-- ==============================================</pre></div></div><br>Création du corps du package<br><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
create or replace package body pkg_prc_hello as
    procedure prc_hello is 
    begin
        dbms_output.put_line('Bonjour tout le monde');
    end prc_hello;
    -- ==============================================
    procedure prc_hello(name in varchar2) is 
    begin
        dbms_output.put_line('Bonjour ' || name);
    end prc_hello;
end pkg_prc_hello;
/
-- ==============================================</pre></div></div><br>Appel des procédures<br><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
begin 
    pkg_prc_hello.prc_hello; 
    pkg_prc_hello.prc_hello('Gerard KESSE'); 
end;
/
-- ==============================================</pre></div></div><br><h2 class="Title7 GTitle2" id="Oracle-Database-Curseur"><a class="Link9" href="#Oracle-Database">Curseur</a></h2><br>Un <b>curseur </b>est un pointeur vers une zone mémoire créee par Oracle, appelée zone de contexte, pour le traitement d'une instruction SQL, qui contient toutes les informations nécessaires au traitement de l'instruction ; par exemple, le nombre de lignes traitées, etc. Il existe deux types de curseurs : les curseurs implicites et les curseurs explicites. Les curseurs implicites sont automatiquement créés par Oracle chaque fois qu'une instruction SQL est exécutée, lorsqu'il n'y a pas de curseur explicite pour l'instruction.<br><br><h3 class="Title8 GTitle3">Utiliser le curseur implicite (found)</h3><br>-- ==============================================<br>begin <br>    -- execution d'une requete sql (select, insert, update)<br>    update ma_table<br>    set col_1 = ma_donnee_1<br>    where col_2 = ma_donnee_2<br>    --<br>    if sql%found then <br>        -- code si ligne trouvee<br>    end if;  <br>end; <br>/     <br>-- ==============================================<br><br><h3 class="Title8 GTitle3">Utiliser le curseur implicite (notfound)<br></h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
begin 
    -- execution d'une requete sql (select, insert, update)
    update ma_table
    set col_1 = ma_donnee_1
    where col_2 = ma_donnee_2
    --
    if sql%notfound then 
        -- code si ligne non trouve
    end if;  
end; 
/     
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Utiliser le curseur implicite (isopen)</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
begin 
    -- execution d'une requete sql (select, insert, update)
    update ma_table
    set col_1 = ma_donnee_1
    where col_2 = ma_donnee_2
    --
    if sql%isopen then 
        -- code si curseur ouvert
    end if;  
end; 
/     
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Utiliser le curseur implicite (rowcount)</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
begin 
    -- execution d'une requete sql (select, insert, update)
    update ma_table
    set col_1 = ma_donnee_1
    where col_2 = ma_donnee_2
    --
    if sql%found then 
        -- recuperation du nombre de ligne
        nombre_ligne := sql%rowcount;
    end if;  
end; 
/     
-- ==============================================</pre></div></div><br><br><h3 class="Title8 GTitle3">Utiliser un curseur explicite (cursor)<br></h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration des colonnes de table;
    c_col_1 ma_table.col_1%type;
    c_col_2 ma_table.col_2%type;
    c_col_3 ma_table.col_3%type;
    -- declaration du curseur
    cursor mon_curseur is
        select col_1, col_2, col_3
        from ma_table;
begin 
    -- ouverture du curseur
    open mon_curseur;
    -- parcours des donnees du curseur
    loop
        -- recuperation de la ligne de donnees suivante du curseur
        fetch mon_curseur into c_col_1, c_col_2, c_col_3;
        -- fermeture de la boucle si ligne non trouvee dans le curseur
        exit when mon_curseur%notfound;
        -- utilisation des colonnes de donnees du curseur
        -- c_col_1
        -- c_col_2
        -- c_col_3
    end loop;
end; 
/     
-- ==============================================</pre></div></div><br><h2 class="Title7 GTitle2" id="Oracle-Database-Enregistrement"><a class="Link9" href="#Oracle-Database">Enregistrement</a></h2><br>Un <b>enregistrement </b>est une structure de données qui peut contenir des éléments de données de différents types. Les enregistrements se composent de différents champs, similaires à une ligne d'une table de base de données.<br><br><h3 class="Title8 GTitle3">Création d'un enregistrement (table)</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration de l'enregistrement
    mon_enregsitrement ma_table%rowtype;
begin 
    -- chargement de l'enregsitrement
    select * into mon_enregsitrement
    from ma_table
    where col_1 = ma_donnee_1;
    -- utilisation des colonnes de mon enregistrement
    -- mon_enregsitrement.col_1
    -- mon_enregsitrement.col_2
    -- mon_enregsitrement.col_3
end; 
/     
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Créer un enregistrement (curseur)</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration de mon curseur
    cursor mon_curseur is
        select col_1, col_2, col_3
        from ma_table;
    -- declaration de l'enregistrement
    mon_enregsitrement mon_curseur%rowtype;
begin 
    -- ouverture de mon curseur
    open mon_curseur;
    -- parcours de mon curseur
    loop
        -- recuperation la ligne suivante de mon curseur
        fetch mon_curseur into mon_enregsitrement;
        -- fermeture de la boucle si ligne non trouvee
        exit when mon_curseur%notfound;
        -- utilisation des colonnes de mon enregistrement
        -- mon_enregsitrement.col_1
        -- mon_enregsitrement.col_2
        -- mon_enregsitrement.col_3
    end loop;
    -- fermeture de mon curseur
    close mon_curseur;
end; 
/     
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Créer un enregistrement (utilisateur)</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration du type de l'enregistrement
    type mon_type_enregsitrement is record (
        col_1 mon_type_1(ma_taille_1),
        col_2 mon_type_2(ma_taille_2),
        col_3 mon_type_3(ma_taille_3)
    );
    -- declaration de l'enregistrement
    mon_enregsitrement mon_type_enregsitrement;
begin 
    -- chargement de mon enregistrement
    mon_enregsitrement.col_1 = ma_donnee_1;
    mon_enregsitrement.col_2 = ma_donnee_2;
    mon_enregsitrement.col_3 = ma_donnee_3;
    -- utilisation des colonnes de mon enregistrement
    -- mon_enregsitrement.col_1
    -- mon_enregsitrement.col_2
    -- mon_enregsitrement.col_3
end; 
/     
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Utiliser un enregistrement comme paramètre</h3><br>Création de la procédure<br><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration du type de l'enregistrement
    type mon_type_enregsitrement is record (
        col_1 mon_type_1(ma_taille_1),
        col_2 mon_type_2(ma_taille_2),
        col_3 mon_type_3(ma_taille_3)
    );
procedure ma_procedure(mon_enregsitrement mon_type_enregsitrement) is
begin 
    -- utilisation des colonnes de mon enregistrement
    -- mon_enregsitrement.col_1
    -- mon_enregsitrement.col_2
    -- mon_enregsitrement.col_3
end; 
/     
-- ==============================================</pre></div></div><br>Utilisation de la procédure<br><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration du type de l'enregistrement
    type mon_type_enregsitrement is record (
        col_1 mon_type_1(ma_taille_1),
        col_2 mon_type_2(ma_taille_2),
        col_3 mon_type_3(ma_taille_3)
    );
    -- declaration de l'enregistrement
    mon_enregsitrement mon_type_enregsitrement;
begin 
    -- chargement de mon enregistrement
    mon_enregsitrement.col_1 = ma_donnee_1;
    mon_enregsitrement.col_2 = ma_donnee_2;
    mon_enregsitrement.col_3 = ma_donnee_3;
    -- utilisation de la procedure
    ma_procedure(mon_enregsitrement);
end; 
/     
-- ==============================================</pre></div></div><br><h2 class="Title7 GTitle2" id="Oracle-Database-Exception"><a class="Link9" href="#Oracle-Database">Exception</a></h2><br>Une <b>exception </b>est une condition d'erreur lors de l'exécution d'un programme. PL/SQL aide les programmeurs à détecter de telles conditions à l'aide du bloc exception dans le programme et une action appropriée est entreprise contre la condition d'erreur. Il existe deux types d'exceptions : les exceptions définies par le système et les exceptions définies par l'utilisateur<br><br><h3 class="Title8 GTitle3">Capturer l'exception (no_data_found)</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration des colonnes de table
    c_col_1 ma_table.col_1%type;
    c_col_2 ma_table.col_2%type;
    c_col_3 ma_table.col_3%type;
begin
    -- execution d'une requete sql
    select col_1, col_2, col_3
    into c_col_1, c_col_2, c_col_3
    from ma_table
    where col_4 = ma_donnee_4;
    -- utilisation des variables
    -- c_col_1
    -- c_col_2
    -- c_col_3
exception
    when no_data_found then
        -- code exception si donnee non trouvee
    when others then
        -- code exception par defaut
end; 
/     
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Créer une exception utilisateur</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration des donnees de table;
    c_col_1 ma_table.col_1%type;
    c_col_2 ma_table.col_2%type;
    c_col_3 ma_table.col_3%type;
    -- declaration de l'exception;
    mon_exception exception;
begin
    if ma_condition = false then
        -- lancement de l'exception
        raise mon_exception;
    else
        -- execution d'une requete sql
        select col_1, col_2, col_3
        into c_col_1, c_col_2, c_col_3
        from ma_table
        where col_4 = ma_donnee_4;
        -- utilisation des colonnes de donnees
        -- c_col_1
        -- c_col_2
        -- c_col_3
    end if;
exception
    when mon_exception then
        -- code si exception utilisateur
    when no_data_found then
        -- code si exception donnee non trouvee
    when others then
        -- code si exception par defaut
end; 
/     
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Liste des exceptions prédéfinies</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">Exception	        | Error | CODE   | Description
--------------------+-------+--------+------------
ACCESS_INTO_NULL    | 06530 | -6530  | si un objet null reçoit automatiquement une valeur.
--------------------+-------+--------+------------
CASE_NOT_FOUND      | 06592 | -6592  | si aucun choix pour la clause WHEN...CASE n'est sélectionné
                                       et pas de clause ELSE.
--------------------+-------+--------+------------
COLLECTION_IS_NULL  | 06531 | -6531  | si un programme tente d'appliquer des méthodes de collecte 
                                       autres que EXISTS à une table ou un varray imbriqué non initialisé, 
                                       ou le programme tente d'affecter des valeurs aux éléments d'une table 
                                       ou d'un varray imbriqué non initialisé.
--------------------+-------+--------+------------
DUP_VAL_ON_INDEX    | 00001 | -1     | si des valeurs en double sont tentées d'être stockées dans une colonne 
                                       avec un index unique.
--------------------+-------+--------+------------
INVALID_CURSOR      | 01001 | -1001  | si des tentatives sont faites pour effectuer une opération de curseur 
                                       qui n'est pas autorisée, telle que la fermeture d'un curseur non ouvert.
--------------------+-------+--------+------------
NUMÉRO INVALIDE     | 01722 | -1722  | si la conversion d'une chaîne de caractères en nombre échoue 
                                       car la chaîne ne représente pas un nombre valide.
--------------------+-------+--------+------------
LOGIN_DENIED        | 01017 | -1017  | si un programme tente de se connecter à la base de données 
                                          avec un nom d'utilisateur ou un mot de passe invalide.
--------------------+-------+--------+------------
NO_DATA_FOUND       | 01403 | +100   | si une instruction SELECT INTO ne renvoie aucune ligne.
--------------------+-------+--------+------------
NOT_LOGGED_ON       | 01012 | -1012  | si un appel de base de données est émis sans être connecté à la base de données.
--------------------+-------+--------+------------
PROGRAM_ERROR       | 06501 | -6501  | si PL/SQL a un problème interne.
--------------------+-------+--------+------------
ROWTYPE_MISMATCH    | 06504 | -6504  | si un curseur récupère une valeur dans une variable ayant un type de données incompatible.
--------------------+-------+--------+------------
SELF_IS_NULL        | 30625 | -30625 | si une méthode membre est invoquée, mais que l'instance du type d'objet n'a pas été initialisée.
--------------------+-------+--------+------------
STORAGE_ERROR       | 06500 | -6500  | si PL/SQL manque de mémoire ou que la mémoire est corrompue.
--------------------+-------+--------+------------
TOO_MANY_ROWS       | 01422 | -1422  | si une instruction SELECT INTO renvoie plusieurs lignes.
--------------------+-------+--------+------------
VALUE_ERROR         | 06502 | -6502  | si une erreur d'arithmétique, de conversion, de troncature 
                                          ou de contrainte de taille se produit.
--------------------+-------+--------+------------
ZERO_DIVIDE         | 01476 | 1476   | si on tente de diviser un nombre par zéro.
--------------------+-------+--------+------------</pre></div></div><br><h2 class="Title7 GTitle2" id="Oracle-Database-Declencheur"><a class="Link9" href="#Oracle-Database">Déclencheur</a></h2><br>Les <b>déclencheurs </b>sont des programmes stockés, qui sont automatiquement exécutés ou déclenchés lorsque certains événements se produisent. Les déclencheurs sont, en fait, écrits pour être exécutés en réponse à l'un des événements suivants : une instruction de manipulation de base de données (DML) (DELETE, INSERT ou UPDATE), une instruction de définition de base de données (DDL) (CREATE, ALTER ou DROP) ou une opération de base de données (SERVERERROR, LOGON, LOGOFF, STARTUP ou SHUTDOWN). Les déclencheurs peuvent être définis sur la table, la vue, le schéma ou la base de données auquel l'événement est associé.<br><br><h3 class="Title8 GTitle3">Créer un déclencheur</h3><br>Création du trigger<br><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
create or replace trigger mon_trigger
    before delete or insert or update on ma_table
    for each row
    when (new.col_1 = ma_donnee_1)
declare
    -- declaration des variables
    col_1_diff number;
begin
    -- execution de l'operation avant
    col_1_diff := :new.col_1 - :old.col_1;
    -- utilisation des donnees
    -- :new.col_1
    -- :old.col_1
    -- col_1_diff
end; 
/     
-- ==============================================</pre></div></div><br>Déclenchement du trigger (insert)<br><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
insert into ma_table (col_1, col_2, col_3)
values (ma_donnee_1, ma_donnee_2, ma_donnee_3)
-- ==============================================</pre></div></div><br>Déclenchement du trigger (update)<br><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
update ma_table 
set col_1 = ma_donnee_1_2
where col_2 = ma_donnee_2
-- ==============================================</pre></div></div><br><h2 class="Title7 GTitle2" id="Oracle-Database-Collection"><a class="Link9" href="#Oracle-Database">Collection</a></h2><br>Une <b>collection </b>est un groupe ordonné d'éléments ayant le même type de données. Chaque élément est identifié par un indice unique qui représente sa position dans la collection. PL/SQL fournit trois types de collections : les tableaux indexés ou tableaux associatifs, les tableaux imbriqués et les tableaux de taille variable ou varray.<br><br><h3 class="Title8 GTitle3">Créer un tableau associatif (utilisateur)<br></h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration du type de la collection
    type mon_type_collection is
        table of number index by varchar2(ma_taille)
    -- declaration de la collection
    ma_collection mon_type_collection;
    -- declaration de variable
    ma_cle varchar2(ma_chaine);
begin
    -- chargement de la collection
    ma_collection('cle_1') := nombre_1;
    ma_collection('cle_2') := nombre_2;
    ma_collection('cle_3') := nombre_3;
    -- parcours de la collection
    ma_cle := ma_collection.first;
    while ma_cle is not null loop
        -- utilisation des donnees
        -- ma_cle
        -- ma_collection(ma_cle)
        -- recuperation de la donnee suivante
        ma_cle := ma_collection.next(ma_cle);
    end loop;
end; 
/     
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Créer un tableau indexé (table)</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration du curseur
    cursor mon_curseur is
        select col_1 from ma_table;
    -- declaration du type de la collection
    type mon_type_collection is
        table of ma_table.col_1%type index by binary_integer;
    -- declaration de la collection
    ma_collection mon_type_collection;
    -- declaration de variable
    ma_cle integer := 0;
begin
    -- chargement de la collection
    for mon_element in mon_curseur loop
        ma_cle := ma_cle + 1;
        ma_collection(ma_cle) := mon_element.col_1;
    end loop;
    -- parcours de la collection
    ma_cle := ma_collection.first;
    while ma_cle is not null loop
        -- utilisation des donnees
        -- ma_cle
        -- ma_collection(ma_cle)
        -- recuperation de la donnee suivante
        ma_cle := ma_collection.next(ma_cle);
    end loop;
end; 
/     
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Créer un tableau imbriqué (utilisateur)</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration du type de la collection
    type mon_type_collection is
        table of varchar2(20);
    -- declaration de la collection
    ma_collection mon_type_collection;
begin
    -- chargement de la collection
    ma_collection := mon_type_collection('donnee_1', 'donnee_2', 'donnee_3');
    -- parcours de la collection
    for i in 1 .. ma_collection.count loop
        -- utilisation des donnees
        -- i
        -- ma_collection(i)
    end loop;
end; 
/     
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Créer un tableau imbriqué (table)</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration du curseur
    cursor mon_curseur is
        select col_1 from ma_table;
    -- declaration du type de la collection
    type mon_type_collection is
        table of ma_table.col_1%type;
    -- declaration de la collection
    ma_collection mon_type_collection := mon_type_collection();
    -- declaration de variable
    mon_compteur integer := 0;
begin
    -- chargement de la collection
    for mon_element in mon_curseur loop
        mon_compteur := mon_compteur + 1;
        ma_collection.extend;
        ma_collection(mon_compteur) := mon_element.col_1;
    end loop;
    -- parcours de la collection
    for i in 1 .. ma_collection.count loop
        -- utilisation des donnees
        -- i
        -- ma_collection(i)
    end loop;
end; 
/     
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Liste des méthodes associées à une collection</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="txt">Nom         | Description
------------+------------------------------------
EXISTS(n)   | Renvoie TRUE si le nième élément d'une collection existe ; 
            | sinon renvoie FALSE.
------------+------------------------------------
COUNT       | Renvoie le nombre d'éléments qu'une collection contient actuellement.
------------+------------------------------------
LIMIT       | Vérifie la taille maximale d'une collection.
------------+------------------------------------
FIRST       | Renvoie les premiers (plus petits) numéros d'index dans une collection 
            | qui utilise les indices entiers.
------------+------------------------------------
LAST        | Renvoie les derniers (plus grands) numéros d'index d'une collection 
            | qui utilise les indices entiers.
------------+------------------------------------
PRIOR(n)    | Renvoie le numéro d'index qui précède l'index n dans une collection.
------------+------------------------------------
NEXT(n)     | Renvoie le numéro d'index qui succède à l'index n.
------------+------------------------------------
EXTEND      | Ajoute un élément null à une collection.
------------+------------------------------------
EXTEND(n)   | Ajoute n éléments null à une collection.
------------+------------------------------------
EXTEND(n,i) | Ajoute n copies du ième élément à une collection.
------------+------------------------------------
TRIM        | Supprime un élément de la fin d'une collection.
------------+------------------------------------
TRIM(n)     | Supprime n éléments de la fin d'une collection.
------------+------------------------------------
DELETE      | Supprime tous les éléments d'une collection, en définissant COUNT sur 0.
------------+------------------------------------
DELETE(n)   | Supprime le n ième élément d'un tableau associatif avec une clé numérique
            | ou une table imbriquée. Si le tableau associatif a une clé de chaîne, l'élément 
            | correspondant à la valeur de la clé est supprimé. Si n est nul, DELETE(n) ne fait rien.
------------+------------------------------------
DELETE(m,n) | Supprime tous les éléments de la plage m..n d'un tableau associatif ou d'un tableau 
            | imbriqué. Si m est supérieur à n ou si m ou n est nul, DELETE(m,n) ne fait rien.
------------+------------------------------------</pre></div></div><br><h3 class="Title8 GTitle3">Liste des exceptions associées à une collection</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="txt">Exception               | Description
------------------------+------------------------
COLLECTION_IS_NULL	| Vous essayez d'opérer sur une collection atomiquement nulle.
------------------------+------------------------
NO_DATA_FOUND	        | Un indice désigne un élément qui a été supprimé, ou un élément 
                        | inexistant d'un tableau associatif.
------------------------+------------------------
SUBSCRIPT_BEYOND_COUNT	| Un indice dépasse le nombre d'éléments dans une collection.
------------------------+------------------------
SUBSCRIPT_OUTSIDE_LIMIT | Un indice est en dehors de la plage autorisée.
------------------------+------------------------
VALUE_ERROR	        | Un indice est nul ou non convertible en type de clé. 
                        | Cette exception peut se produire si la clé est définie comme une plage 
                        | PLS_INTEGER et que l'indice est en dehors de cette plage.
------------------------+------------------------</pre></div></div><br><h2 class="Title7 GTitle2" id="Oracle-Database-Transaction"><a class="Link9" href="#Oracle-Database">Transaction</a></h2><br>Une <b>transaction </b>de base de données est une unité de travail atomique qui peut consister en une ou plusieurs instructions SQL associées. Elle est appelée atomique car les modifications de la base de données provoquées par les instructions SQL qui constituent une transaction peuvent être collectivement soit validées, c'est-à-dire rendues permanentes dans la base de données, soit annulées (annulées) à partir de la base de données. Une instruction SQL exécutée avec succès et une transaction validée ne sont pas identiques. Même si une instruction SQL est exécutée avec succès, à moins que la transaction contenant l'instruction ne soit validée, elle peut être annulée et toutes les modifications apportées par la ou les instructions peuvent être annulées. Une transaction démarre lorsque : la première instruction SQL est exécutée après la connexion à la base de données ou à chaque nouvelle instruction SQL émise après la fin d'une transaction. Une transaction se termine lorsque : une instruction COMMIT ou ROLLBACK est émise. Un COMMIT est émis automatiquement suite à : une instruction CREATE TABLE, GRANT ou EXIT. Un ROLLBACK est émis automatiquement suite à l'échec d'une instruction. Les instructions INSERT, DELETE et UPDATE doivent être validées pour rendre permanent leurs modifiactions.<br><br><h3 class="Title8 GTitle3">Valider une transaction</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
commit;    
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Annuler une transaction</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
rollback;    
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Activer la validation automatique d'une transaction</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
set autocommit on;    
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Désactiver la validation automatique d'une transaction</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
set autocommit off;    
-- ==============================================</pre></div></div><br><h2 class="Title7 GTitle2" id="Oracle-Database-Date-et-heure"><a class="Link9" href="#Oracle-Database">Date et heure</a></h2><br>La <b>date et l'heure</b> stockent les informations de date et d'heure dans les types de données de caractères et de nombres composés d'informations sur le siècle, l'année, le mois, la date, l'heure, la minute et la seconde.<br><br><h3 class="Title8 GTitle3">Récupérer la date et l'heure courantes</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
select sysdate from dual;    
-- ==============================================

08/31/2012 5:25:34 PM</pre></div></div>&nbsp;<br><h3 class="Title8 GTitle3">Formater la date et l'heure courantes</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
select to_char(current_date, 'DD-MM-YYYY HH:MI:SS') from dual;    
-- ==============================================

31-08-2012 05:26:14</pre></div></div><br><h3 class="Title8 GTitle3">Ajouter des mois à la date et l'heure courantes</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
select add_months(sysdate, nombre_mois) from dual;    
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Liste des chanmps associés à DATETIME et INTERVAL</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="txt">Nom             | Valeurs DATETIME               | Valeurs INTERVAL
----------------+--------------------------------+------------------
YEAR	        | -4712 à 9999 (hors année 0)	 | Tout entier différent de zéro
----------------+--------------------------------+------------------
MONTH	        | 01 à 12	                     | 0 à 11
----------------+--------------------------------+------------------
DAY 	        | 01 à 31 (limité par les        | Tout entier différent de zéro
                | valeurs de MOIS et ANNÉE,      |
                | selon les règles du calendrier |  
                | de la locale)                  |
----------------+--------------------------------+------------------
HOUR	        | 00 à 23	                     | 0 à 23
----------------+--------------------------------+------------------
MINUTE	        | 00 à 59	                     | 0 à 59
----------------+--------------------------------+------------------
SECOND	        | 00 à 59                        | 0 à 59
----------------+--------------------------------+------------------
TIMEZONE_HOUR   | -12 à 14 (la plage s'adapte    | N'est pas applicable
                | aux changements d'heure d'été) |
                | Non applicable pour DATE ou    |
                | TIMESTAMP.                     |
----------------+--------------------------------+------------------
TIMEZONE_MINUTE | 00 à 59 Non applicable pour    | N'est pas applicable
                | DATE ou TIMESTAMP.             |
----------------+--------------------------------+------------------
TIMEZONE_REGION	| Non applicable pour DATE ou    | N'est pas applicable
                | TIMESTAMP.	                 |
----------------+--------------------------------+------------------
TIMEZONE_ABBR	| Non applicable pour DATE ou    | N'est pas applicable
                | TIMESTAMP.	                 |
----------------+--------------------------------+------------------</pre></div></div><br><h3 class="Title8 GTitle3">Liste des fonctions associées à la date et l'heure</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="txt">Nom                     | Description
------------------------+------------------------
ADD_MONTHS(x, y);       | Ajoute y mois à x .
------------------------+------------------------
LAST_DAY(x);            | Renvoie le dernier jour du mois x.	
------------------------+------------------------
MONTHS_BETWEEN(x, y);   | Renvoie le nombre de mois entre x et y .
------------------------+------------------------
NEXT_DAY(x, jour);      | Renvoie la date/ heure du jour suivant après x .
------------------------+------------------------
NEW_TIME ;              | Renvoie la valeur heure/jour d'un fuseau horaire spécifié par l'utilisateur.
------------------------+------------------------
ROUND(x [, unité]);     | Arrondit x .
------------------------+------------------------
SYSDATE();              | Renvoie la date/heure actuelle.
------------------------+------------------------
TRUNC(x [, unité]);     | Tronque x .
------------------------+------------------------</pre></div></div><br><h2 class="Title7 GTitle2" id="Oracle-Database-Sortie-du-SGBD"><a class="Link9" href="#Oracle-Database">Sortie du SGBD</a></h2><br>La <b>sortie du SGBD</b> en PL/SQL est géré par le package DBMS_OUTPUT qui permet d'afficher la sortie, les informations de débogage et d'envoyer des messages à partir de blocs PL/SQL, de sous-programmes, de packages et de déclencheurs.<br><br><h3 class="Title8 GTitle3">Afficher la liste des tables</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
begin
    for t in (select table_name 
    from user_tables) loop
        dbms_output.put_line(t.table_name);
    end loop;
end;
/
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Liste de méthodes associées à dbms_output</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="txt">Nom                                             | Description
------------------------------------------------+----------------------------------
DBMS_OUTPUT.DISABLE;                            | Désactive la sortie des messages.
------------------------------------------------+----------------------------------
DBMS_OUTPUT.ENABLE(                             | Active la sortie des messages. 
buffer_size IN INTEGER DEFAULT 20000);          | Une valeur NULL de buffer_size représente 
                                                | une taille de tampon illimitée.
------------------------------------------------+----------------------------------
DBMS_OUTPUT.GET_LINE (                          | Récupère une seule ligne d'informations 
line OUT VARCHAR2, status OUT INTEGER);         | mises en mémoire tampon.
------------------------------------------------+----------------------------------
DBMS_OUTPUT.GET_LINES (                         | Récupère un tableau de lignes du tampon.
lines OUT CHARARR, numlines IN OUT INTEGER);    |
------------------------------------------------+----------------------------------
DBMS_OUTPUT.NEW_LINE;                           | Place un marqueur de fin de ligne.
------------------------------------------------+----------------------------------
DBMS_OUTPUT.PUT(item IN VARCHAR2);              | Place une ligne partielle dans le tampon.
------------------------------------------------+----------------------------------
DBMS_OUTPUT.PUT_LINE(item IN VARCHAR2);         | Place une ligne dans le tampon.
------------------------------------------------+----------------------------------</pre></div></div><br><h2 class="Title7 GTitle2" id="Oracle-Database-BDD-orientee-objet"><a class="Link9" href="#Oracle-Database">BDD orientée objet</a></h2><br>PL/SQL permet de définir un type d'objet, ce qui aide à concevoir une <b>base de données orientée objet</b> dans Oracle. Un type d'objet vous permet de créer des types composites. L'utilisation d'objets vous permet d'implémenter des objets du monde réel avec une structure de données spécifique et des méthodes pour l'exploiter. Les objets ont des attributs et des méthodes. Les attributs sont des propriétés d'un objet et sont utilisés pour stocker l'état d'un objet ; et les méthodes sont utilisées pour modéliser son comportement. La méthode <b>MAP </b>est une fonction implémentée sans paramètre en entrée de telle manière que sa valeur dépend de la valeur des attributs et permet comparer deux objets entre eux. La méthode <b>ORDER </b>implémente une logique interne pour comparer deux objets entre eux et prend en entrée un seul paramètre du même type que l'objet. PL/SQL permet de créer des objets à partir des objets de base existants. Pour implémenter l'héritage, les objets de base doivent être déclarés comme <b>NOT FINAL</b> . La valeur par défaut est <b>FINALE</b>. La clause <b>NOT INSTANTIABLE</b> permet de déclarer un objet abstrait. Vous ne pouvez pas utiliser un objet abstrait tel quel ; vous devrez créer un sous-type ou un type enfant de ces objets pour utiliser ses fonctionnalités.<br><br><h3 class="Title8 GTitle3">Créer un objet</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
create or replace type mon_type_objet as object (
    attr_1 varchar2(10),
    attr_2 varchar2(20),
    attr_3 varchar2(30)
);
/
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Utiliser un objet</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration de l'objet
    mon_objet mon_type_objet;
begin
    -- chargement de l'objet
    mon_objet := mon_type_objet('donnee_1', 'donnee_2', 'donnee_3');
    -- utilisation de l'objet
    -- mon_objet.attr_1
    -- mon_objet.attr_2
    -- mon_objet.attr_2
end;
/
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Créer un objet avec des méthodes</h3><br>Création de l'objet<br><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
create or replace type mon_type_objet as object (
    attr_1 varchar2(10),
    attr_2 varchar2(20),
    attr_3 varchar2(30),
    member function ma_fonction(arg_1 number) return number,
    member procedure ma_procedure(arg_1 number)
);
/
-- ==============================================</pre></div></div><br>Création du corps de l'objet<br><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
create or replace type body mon_type_objet as
    member function ma_fonction(arg_1 number) return number is
    begin
        -- utilisation des attributs et des arguments
        -- attr_1
        -- attr_2
        -- attr_3
        -- arg_1
        -- mon_retour1 := mon_calcul(attr_1, attr_2, attr_3, arg_1)
        return mon_retour1;
    end ma_fonction;
    -- ==============================================
    member procedure ma_procedure(arg_1 number) is
    begin
        -- utilisation des attributs et des arguments
        -- attr_1
        -- attr_2
        -- attr_3
        -- arg_1
    end ma_procedure;
end;
/
-- ==============================================</pre></div></div><br>Utilisation de l'objet<br><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration des objets
    mon_objet mon_type_objet;
    -- declaration des variables
    mon_retour number;
begin
    -- initialisation des objets
    mon_objet := mon_type_objet(arg_1, arg_2, arg_3);
    -- utilisation de la methode (fonction)
    mon_retour := mon_objet_1.ma_fonction(arg_1);
    -- utilisation de la methode (procedure)
    mon_objet.ma_procedure(arg_1);
end;
/
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Créer un objet avec une méthode (map)</h3><br>Création de l'objet<br><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
create or replace type mon_type_objet as object (
    attr_1 varchar2(10),
    attr_2 varchar2(20),
    attr_3 varchar2(30),
    map member function ma_fonction_map return number
);
/
-- ==============================================</pre></div></div><br>Création du corps de l'objet<br><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
create or replace type body mon_type_objet as
    map member function ma_fonction_map return number is
    begin
        -- utilisation des attributs de l'objet
        -- mon_retour_1 := mon_calcul(attr_1, attr_2, attr_3)
        return mon_retour_1;
    end ma_fonction_map;
end;
/
-- ==============================================</pre></div></div><br>Utilisation de l'objet<br><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration des objets
    mon_objet_1 mon_type_objet;
    mon_objet_2 mon_type_objet;
begin
    -- initialisation des objets
    mon_objet_1 := mon_type_objet(arg_1, arg_2, arg_3);
    mon_objet_2 := mon_type_objet(arg_1, arg_2, arg_3);
    -- utilisation de la methode map (automatique)
    if mon_objet_1 &gt; mon_objet_2 then
        -- code si obj_1 &gt; obj_2
    elsif mon_objet_1 = mon_objet_2 then
        -- code si obj_1 = obj_2
    else
        -- code si obj_1 &lt; obj_2
    end if;
end;
/
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Créer un objet avec une méthode (order)</h3><br>Création de l'objet<br><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
create or replace type mon_type_objet as object (
    attr_1 varchar2(10),
    attr_2 varchar2(20),
    attr_3 varchar2(30),
    order member function ma_fonction_order(obj mon_type_objet) return number
);
/
-- ==============================================</pre></div></div><br>Création du corps de l'objet<br><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
create or replace type body mon_type_objet as
    -- ==============================================
    order member function ma_fonction_order(obj mon_type_objet) return number is
    begin
        -- utilisation des attributs de l'objet (appelant)
        -- mon_retour_1 := mon_calcul(self.attr_1, self.attr_2, self.attr_3)
        -- utilisation des attributs de l'objet (entrant)
        -- mon_retour_2 := mon_calcul(obj.attr_1, obj.attr_2, obj.attr_3)
        -- comparaison des resultat
        if mon_retour_1 &gt; mon_retour_2 then
            return 1;
        elsif mon_retour_1 = mon_retour_2 then
            return 0;
        else
            return -1;
        end if;        
    end ma_fonction_order;
end;
/
-- ==============================================</pre></div></div><br>Utilisation de l'objet<br><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration des objets
    mon_objet_1 mon_type_objet;
    mon_objet_2 mon_type_objet;
begin
    -- initialisation des objets
    mon_objet_1 := mon_type_objet(arg_1, arg_2, arg_3);
    mon_objet_2 := mon_type_objet(arg_1, arg_2, arg_3);
    -- utilisation de la methode order (automatique)
    if mon_objet_1 &gt; mon_objet_2 then
        -- code si obj_1 &gt; obj_2
    elsif mon_objet_1 = mon_objet_2 then
        -- code si obj_1 = obj_2
    else
        -- code si obj_1 &lt; obj_2
    end if;
end;
/
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Créer un héritage d'objet</h3><br>Création de l'objet de base<br><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
create or replace type mon_objet_base as object (
    attr_1 varchar2(10),
    member function ma_fonction return number,
    not final member procedure ma_procedure
) not final;
/
-- ==============================================</pre></div></div><br>Création du corps de l'objet de base<br><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
create or replace type body mon_objet_base as
    member function ma_fonction return number is
    begin
        -- utilisation des attributs de l'objet
        -- mon_retour_1 := mon_calcul(attr_1)
        return mon_retour_1;
    end ma_fonction;
    -- ==============================================
    member procedure ma_procedure is
    begin
        -- utilisation des attributs de l'objet
        -- attr_1
    end ma_procedure;
end;
/
-- ==============================================</pre></div></div><br>Création de l'objet héritier<br><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
create or replace type mon_objet_heritier under mon_objet_base (
    attr_2 varchar2(20),
    overriding member procedure ma_procedure
);
/
-- ==============================================</pre></div></div><br>Création du corps de l'objet héritier<br><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
create or replace type body mon_objet_heritier as
    overriding member procedure ma_procedure is
    begin
        -- utilisation des attributs de l'objet
        -- attr_1
        -- attr_2
    end ma_procedure;
end;
/
-- ==============================================</pre></div></div><br>Utilisation des objets de base et héritier<br><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration des objets
    mon_obj_base mon_objet_base;
    mon_obj_heritier mon_objet_heritier;
    -- declaration des objets
    mon_retour number;
begin
    -- initialisation des objets
    mon_obj_base := mon_objet_base(arg_1);
    mon_obj_heritier := mon_objet_heritier(arg_1, arg_2);
    -- utilisation de la methode de l'objet (base)
    mon_retour := mon_obj_base.ma_fonction;
    mon_obj_base.ma_procedure;
    -- utilisation de la methode de l'objet (heritier)
    mon_retour := mon_obj_heritier.ma_fonction;
    mon_obj_heritier.ma_procedure;
end;
/
-- ==============================================</pre></div></div><br><h3 class="Title8 GTitle3">Créer un objet abstrait</h3><br>Création de l'objet abstrait<br><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
create or replace type mon_objet_base as object (
    attr_1 varchar2(10),
    member function ma_fonction return number,
    not instantiable not final member procedure ma_procedure
) not instantiable not final;
/
-- ==============================================</pre></div></div><br>Création du corps de l'objet abstrait<br><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
create or replace type body mon_objet_base as
    member function ma_fonction return number is
    begin
        -- utilisation des attributs de l'objet
        -- mon_retour_1 := mon_calcul(attr_1)
        return mon_retour_1;
    end ma_fonction;
    -- ==============================================
    member procedure ma_procedure is
    begin
        -- utilisation des attributs de l'objet
        -- attr_1
    end ma_procedure;
end;
/
-- ==============================================</pre></div></div><br>Création de l'objet héritier<br><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
create or replace type mon_objet_heritier under mon_objet_base (
    attr_2 varchar2(20),
    overriding member procedure ma_procedure
);
/
-- ==============================================</pre></div></div><br>Création du corps de l'objet héritier<br><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
create or replace type body mon_objet_heritier as
    overriding member procedure ma_procedure is
    begin
        -- utilisation des attributs de l'objet
        -- attr_1
        -- attr_2
    end ma_procedure;
end;
/
-- ==============================================</pre></div></div><br>Utilisation de l'objet héritier<br><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">-- ==============================================
declare
    -- declaration des objets
    mon_obj_heritier mon_objet_heritier;
    -- declaration des objets
    mon_retour number;
begin
    -- initialisation des objets
    mon_obj_heritier := mon_objet_heritier(arg_1, arg_2);
    -- utilisation de la methode de l'objet (heritier)
    mon_retour := mon_obj_heritier.ma_fonction;
    mon_obj_heritier.ma_procedure;
end;
/
-- ==============================================</pre></div></div><br></div></div></div></div><br><div class="Content2 GTitle1"><div class="MainBlock2"><div class="Content"><h1 class="Title2 Center" id="Oracle-SQL-Developer"><a class="Link3" href="#">Oracle SQL Developer</a></h1><div class="Body3"><br><b>Oracle SQL Developer</b> est un environnement de développement intégré gratuit qui simplifie le développement et la gestion d'Oracle Database dans les déploiements traditionnels et cloud. SQL Developer propose un développement complet de bout en bout de vos applications PL/SQL, une feuille de calcul pour exécuter des requêtes et des scripts, une console DBA pour gérer la base de données, une interface de rapports, une solution complète de modélisation de données et une plateforme de migration pour déplacer votre Bases de données tierces vers Oracle.<br><br><div class="Content0 GSummary2"><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-SQL-Developer-Installer-l-environnement-JDK-8-sous-Windows">Installer l'environnement JDK 8 sous Windows</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-SQL-Developer-Installer-l-environnement-Oracle-SQL-Developer-sous-Windows">Installer l'environnement Oracle SQL Developer sous Windows</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-SQL-Developer-Demarrer-une-nouvelle-connexion">Démarrer une nouvelle connexion</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-SQL-Developer-Executer-un-nouveau-script">Exécuter un nouveau script</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Oracle-SQL-Developer-Executer-un-script-existant">Exécuter un script existant</a></div></div><br><h2 class="Title7 GTitle2" id="Oracle-SQL-Developer-Installer-l-environnement-JDK-8-sous-Windows"><a class="Link9" href="#Oracle-SQL-Developer">Installer l'environnement JDK 8 sous Windows</a></h2><br><h3 class="Title8 GTitle3">Télécharger JDK 8</h3><br><a class="Link7 GLink1" style="color:lime;" target="_blank" href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html">https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html</a><br><br><b>jdk-8u291-windows-x64.exe</b><br><br><h3 class="Title8 GTitle3">Installer JDK 8</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="batchfile">jdk-8u291-windows-x64.exe
Next
Install To -&gt; C:\Program Files\Java\jdk1.8.0_291\
Next
Installer dans -&gt; C:\Program Files\Java\jre1.8.0_291\
Suivant
Close</pre></div></div><br><h2 class="Title7 GTitle2" id="Oracle-SQL-Developer-Installer-l-environnement-Oracle-SQL-Developer-sous-Windows"><a class="Link9" href="#Oracle-SQL-Developer">Installer l'environnement Oracle SQL Developer sous Windows</a></h2><br><h3 class="Title8 GTitle3">Télécharger Oracle SQL Developer</h3><br><a class="Link7 GLink1" style="color:lime;" target="_blank" href="https://www.oracle.com/tools/downloads/sqldev-downloads.html">https://www.oracle.com/tools/downloads/sqldev-downloads.html</a><br><br><b>sqldeveloper-20.4.1.407.0006-no-jre.zip</b><br><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="batchfile">sqldeveloper-20.4.1.407.0006-no-jre.zip
Clic droit
Extraire vers sqldeveloper-20.4.1.407.0006-no-jre\</pre></div></div><br><h3 class="Title8 GTitle3">Installer Oracle SQL Developer</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="batchfile">sqldeveloper-20.4.1.407.0006-no-jre
sqldeveloper.exe
Java JDK Home -&gt; C:\Program Files\Java\jdk1.8.0_291
OK
Importer une installation SQL ? -&gt; Non
Cocher -&gt; Autoriser l'envoi de rapports d'utilisation à Oracle
OK</pre></div></div><br><h2 class="Title7 GTitle2" id="Oracle-SQL-Developer-Demarrer-une-nouvelle-connexion"><a class="Link9" href="#Oracle-SQL-Developer">Démarrer une nouvelle connexion</a></h2><br><h3 class="Title8 GTitle3">Démarrer une nouvelle connexion</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="batchfile">Oracle connexions
Clic droit
Nouvelle connexion
Name -&gt; MY_CONNEXION
Type de base de données -&gt; Oracle
Informations utilisateur
Type d'authentification -&gt; Par défaut
Nom d'utilisateur -&gt; sys
Rôle -&gt; SYSDBA
Mot de passe -&gt; xxxxxxxxxx
Type de connexion -&gt; De base
Détails
Nom de l'hôte -&gt; localhost
Port -&gt; 1521
Cocher -&gt; SID -&gt; xe
Tester
Connexion</pre></div></div><br><h3 class="Title8 GTitle3">Ouvrir une feuille de calcul SQL</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="batchfile">Oracle connexions
MY_CONNECTION
Clic droit
Ouvrir une feuille de calcul SQL</pre></div></div><br><h3 class="Title8 GTitle3">Exécuter une requête SQL</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="sql">MY_CONNECTION
Feuille de calcul

select * from v$version;

Clic droit
Exécuter l'instruction (F9)</pre></div></div><br><h2 class="Title7 GTitle2" id="Oracle-SQL-Developer-Executer-un-nouveau-script"><a class="Link9" href="#Oracle-SQL-Developer">Exécuter un nouveau script</a></h2><br><h3 class="Title8 GTitle3">Exécuter un nouveau script</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="batchfile">Fichier
Ouvrir
Nom du fichier -&gt; script.sql
Ouvrir
Exécuter un script (F5)
Connexion -&gt; MY_CONNEXION
OK</pre></div></div><br><h2 class="Title7 GTitle2" id="Oracle-SQL-Developer-Executer-un-script-existant"><a class="Link9" href="#Oracle-SQL-Developer">Exécuter un script existant</a></h2><br><h3 class="Title8 GTitle3">Exécuter un script existant</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="batchfile">Fichier
Ouvrir
Nom du fichier -&gt; script.sql
Ouvrir
Exécuter un script (F5)</pre></div></div><br></div></div></div></div><br><div class="Content2 GTitle1"><div class="MainBlock2"><div class="Content"><h1 class="Title2 Center" id="OCILIB"><a class="Link3" href="#">OCILIB</a></h1><div class="Body3"><br><b>OCILIB </b>est un driver C/C++ open source et multiplateforme qui offre un accès efficace aux bases de données Oracle. La bibliothèque OCILIB offre une API riche, complète et facile à utiliser sur toutes les plateformes Oracle. Elle est écrite en code ISO C99 pur avec une prise en charge native ISO C Unicode et fournit également une API C++ écrite en standard C++03. Elle permet une productivité élevée et encapsule OCI (Oracle Call Interface) qui est le wrapper OCI le plus complet disponible. OCILIB est développé par Vincent Rogier.<br><br><div class="Content0 GSummary2"><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#OCILIB-Installer-l-environnement-OCILIB-sous-Windows">Installer l'environnement OCILIB sous Windows</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#OCILIB-Compiler-un-projet-OCILIB">Compiler un projet OCILIB</a></div></div><br><h2 class="Title7 GTitle2" id="OCILIB-Installer-l-environnement-OCILIB-sous-Windows"><a class="Link9" href="#OCILIB">Installer l'environnement OCILIB sous Windows</a></h2><br><h3 class="Title8 GTitle3">Télécharger OCILIB</h3><br><a class="Link7 GLink1" style="color:lime;" target="_blank" href="https://github.com/vrogier/ocilib/releases">https://github.com/vrogier/ocilib/releases</a><br><br><b>ocilib-4.7.3-windows.zip</b><br><br><h3 class="Title8 GTitle3">Extraire OCILIB</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="c_cpp">ocilib-4.7.3-windows.zip
Clic droit
Extraire vers ocilib-4.7.3-windows\</pre></div></div><br><h2 class="Title7 GTitle2" id="OCILIB-Compiler-un-projet-OCILIB"><a class="Link9" href="#OCILIB">Compiler un projet OCILIB</a></h2><br><h3 class="Title8 GTitle3">Configurer les variables d'environnement</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="batchfile">::===============================================
set "PATH=winlibs-x86_64-posix-seh-gcc-11.1.0-llvm-12.0.0-mingw-w64-9.0.0-r2\mingw64\bin;%PATH%"
set "PATH=ocilib-4.7.3-windows\lib64;%PATH%"
::===============================================</pre></div></div><br><h3 class="Title8 GTitle3">Compiler le projet</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="batchfile">g++ -std=gnu++11  -c main.cpp -o main.o -Iocilib-4.7.3-windows\include
g++ -std=gnu++11  -o rdcpp.exe main.o  -Locilib-4.7.3-windows\lib64 -lociliba -locilibw</pre></div></div><br></div></div></div></div><br><div class="Content2 GTitle1"><div class="MainBlock2"><div class="Content"><h1 class="Title2 Center" id="Borland-C---Builder"><a class="Link3" href="#">Borland C++ Builder</a></h1><div class="Body3"><br><b>Borland C++Builder</b> est un logiciel de développement rapide d'applications (RAD) conçu par Borland qui reprend les mêmes concepts, la même interface et la même bibliothèque que Delphi en utilisant le langage C++. Il permet de créer rapidement des applications Win32, Win64, MacOS, iOS, Android, ainsi qu'une interface graphique avec son éditeur de ressources. Utilisant en interne le compilateur Clang, ll est compatible avec la version de norme ISO C++ C++17.<br><br><div class="Content0 GSummary2"><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Borland-C---Builder-Installer-l-envrionnement-Borland-C---Builder-sous-Windows">Installer l'envrionnement Borland C++ Builder sous Windows</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Borland-C---Builder-Documentation-sur-Borland-C---Builder">Documentation sur Borland C++ Builder</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Borland-C---Builder-Creer-une-application-console">Créer une application console</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Borland-C---Builder-Creer-une-application-GUI-OWL">Créer une application GUI OWL</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#Borland-C---Builder-Creer-une-nouvelle-ressource">Créer une nouvelle ressource</a></div></div><br><h2 class="Title7 GTitle2" id="Borland-C---Builder-Installer-l-envrionnement-Borland-C---Builder-sous-Windows"><a class="Link9" href="#Borland-C---Builder">Installer l'envrionnement Borland C++ Builder sous Windows</a></h2><br><h3 class="Title8 GTitle3">Télécharger Borland C++ Builder</h3><br><a class="Link7 GLink1" style="color:lime;" target="_blank" href="https://archive.org/details/BorlandC5.02">https://archive.org/details/BorlandC5.02</a><br><br><b>BORLAND C++.zip</b><br><br><h3 class="Title8 GTitle3">Extraire Borland C++ Builder</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="batchfile">BORLAND C++.zip
Clic droit
Extraire vers BORLAND C++\</pre></div></div><br><h3 class="Title8 GTitle3">Installer Borland C++</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="batchfile">BORLAND C++
BORLAND C
SETUP.EXE
Borland C++ 5.02
INSTALL.TXT -&gt; Next
Fermer -&gt; Fichier
Cocher -&gt; Typical
Next
Location of Borland C++ -&gt; C:\BC5
Location of Borland C++ Default Desktop -&gt; C:\BC5\BIN
Source Drive -&gt; C
Windows Directory -&gt; C:\WINDOWS
Next
Database Location -&gt; C:\Program Files\Borland\Common Files\BDE
Configuration Location -&gt; C:\Program Files\Borland\Common Files\BDE
Cocher -&gt; Maintain configuration to support existing Win3.1 applications
Next
BDE Location -&gt; C:\BDE32
Next
Install
OK
Reboot -&gt; OK
README.TXT -&gt; Next
Fermer -&gt; Fichier
OK
Registration -&gt; Next
OK</pre></div></div><br><h2 class="Title7 GTitle2" id="Borland-C---Builder-Documentation-sur-Borland-C---Builder"><a class="Link9" href="#Borland-C---Builder">Documentation sur Borland C++ Builder</a></h2><br><h3 class="Title8 GTitle3">Documentation sur Borland C++ v5.02</h3><br><a class="Link7 GLink1" style="color:lime;" target="_blank" href="http://docplayer.fr/12623573-Tp1-c-presentation-de-borland-c-5-02-rappels-de-c.html">http://docplayer.fr/12623573-Tp1-c-presentation-de-borland-c-5-02-rappels-de-c.html</a><br><br><h2 class="Title7 GTitle2" id="Borland-C---Builder-Creer-une-application-console"><a class="Link9" href="#Borland-C---Builder">Créer une application console</a></h2><br><h3 class="Title8 GTitle3">Créer une applocation console</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="c_cpp">File
New
Project
Project Path and Name -&gt; ReadyTest\rdcpp.ide
Target Name -&gt; rcpp
Target Type -&gt; Application (.exe)
Plateform -&gt; Win32
Target Model -&gt; console
Framework -&gt; Décocher Tout
Controls -&gt; Décocher Tout
Librairies -&gt; Décocher Tout
Cocher -&gt; Dynamic
Cocher -&gt; Multithread
Advanced
Initial Nodes
Cocher -&gt; .cpp Node
Décocher -&gt; .rc
Décocher -&gt; .def
OK
OK</pre></div></div><br><h3 class="Title8 GTitle3">Editer le programme principal (rdcpp.cpp)</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="c_cpp">//===============================================
#include &lt;iostream&gt;
#include &lt;stdlib&gt;
//===============================================
int main(int argc, char** argv) {
   cout &lt;&lt; "Bonjour tout le monde\n";
   system("pause");
   return 0;
}
//===============================================</pre></div></div><br><h3 class="Title8 GTitle3">Compiler le programme</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="c_cpp">Project
Compile</pre></div></div><br><h3 class="Title8 GTitle3">Compiler le projet</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="c_cpp">Project
Make all</pre></div></div><br><h3 class="Title8 GTitle3">Construire le projet</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="c_cpp">Project
Build all</pre></div></div><br><h3 class="Title8 GTitle3">Exécuter le projet</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="c_cpp">Project
Run</pre></div></div><br><h3 class="Title8 GTitle3">Résultat</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="c_cpp">Bonjour tout le monde</pre></div></div><br><h2 class="Title7 GTitle2" id="Borland-C---Builder-Creer-une-application-GUI-OWL"><a class="Link9" href="#Borland-C---Builder">Créer une application GUI OWL</a></h2><br><h3 class="Title8 GTitle3">Créer une applocation GUI</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="c_cpp">File
New
Project
Project Path and Name -&gt; ReadyTest\rdcpp.ide
Target Name -&gt; rcpp
Target Type -&gt; Application (.exe)
Plateform -&gt; Win32
Target Model -&gt; GUI
Framework -&gt; Décocher -&gt; MFC
Framework -&gt; Cocher -&gt; OWL
Framework -&gt; Décocher -&gt; OCF
Controls -&gt; Décocher Tout
Librairies -&gt; Décocher Tout
Cocher -&gt; Dynamic
Cocher -&gt; Multithread
Advanced
Initial Nodes
Cocher -&gt; .cpp Node
Décocher -&gt; .rc
Décocher -&gt; .def
OK
OK</pre></div></div><br><h3 class="Title8 GTitle3">Editer le programme principal (rdcpp.cpp)</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="c_cpp">//===============================================
#include &lt;owl\applicat.h&gt;
//===============================================
int OwlMain(int argc, char** argv) {
    return TApplication().Run();
}
//===============================================</pre></div></div><br><h3 class="Title8 GTitle3">Compiler le programme</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="c_cpp">Project
Compile</pre></div></div><br><h3 class="Title8 GTitle3">Compiler le projet</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="c_cpp">Project
Make all</pre></div></div><br><h3 class="Title8 GTitle3">Construire le projet</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="c_cpp">Project
Build all</pre></div></div><br><h3 class="Title8 GTitle3">Exécuter le projet</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="c_cpp">Project
Run</pre></div></div><br><h3 class="Title8 GTitle3">Résultat</h3><br><div class="Img3 GImage"><img src="/Tutoriels/Resources/ToolBox/img/i_borland_gui_owl.png" alt="/Tutoriels/Resources/ToolBox/img/i_borland_gui_owl.png"></div><br><h2 class="Title7 GTitle2" id="Borland-C---Builder-Creer-une-nouvelle-ressource"><a class="Link9" href="#Borland-C---Builder">Créer une nouvelle ressource</a></h2><br><h3 class="Title8 GTitle3">Créer une nouvelle ressource</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="c_cpp">rdcpp.rc
Doucle clic
Identifiers
Clic droit
New Resource
MENU
OK</pre></div></div><br></div></div></div></div><br><div class="Content2 GTitle1"><div class="MainBlock2"><div class="Content"><h1 class="Title2 Center" id="CSV"><a class="Link3" href="#">CSV</a></h1><div class="Body3"><br><b>Comma-separated values</b> (CSV) est un format texte ouvert représentant des données tabulaires sous forme de valeurs séparées par des virgules. Ce format n'a jamais vraiment fait l'objet d'une spécification formelle. Toutefois, la RFC 41801 décrit la forme la plus courante et établit son type MIME « text/csv », enregistré auprès de l'IANA. Un fichier CSV est un fichier texte, par opposition aux formats dits « binaires ». Chaque ligne du texte correspond à une ligne du tableau et les virgules correspondent aux séparations entre les colonnes. Les portions de texte séparées par une virgule correspondent ainsi aux contenus des cellules du tableau. Une ligne est une suite ordonnée de caractères terminée par un caractère de fin de ligne (line break – LF ou CRLF), la dernière ligne pouvant en être exemptée.<br><br><div class="Content0 GSummary2"><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#CSV-Installer-l-environnement-Fast-C---CSV-Parser-sous-MSYS2">Installer l'environnement Fast C++ CSV Parser sous MSYS2</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#CSV-Compiler-un-projet-Fast-C---CSV-Parser">Compiler un projet Fast C++ CSV Parser</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#CSV-Lire-un-fichier-CVS-sous-Fast-C---CSV-Parser">Lire un fichier CVS sous Fast C++ CSV Parser</a></div></div><br><h2 class="Title7 GTitle2" id="CSV-Installer-l-environnement-Fast-C---CSV-Parser-sous-MSYS2"><a class="Link9" href="#CSV">Installer l'environnement Fast C++ CSV Parser sous MSYS2</a></h2><br><b>Fast C++ CSV Parser</b> est une petite bibliothèque d'en-tête rapide, facile à utiliser et permettant de lire les fichiers CSV (comma separated value).<br><br><h3 class="Title8 GTitle3">Télécharger Fast C++ CSV Parser</h3><br><a class="Link7 GLink1" style="color:lime;" target="_blank" href="https://github.com/ben-strasser/fast-cpp-csv-parser">https://github.com/ben-strasser/fast-cpp-csv-parser</a><br><br><h2 class="Title7 GTitle2" id="CSV-Compiler-un-projet-Fast-C---CSV-Parser"><a class="Link9" href="#CSV">Compiler un projet Fast C++ CSV Parser</a></h2><br><h3 class="Title8 GTitle3">Compiler le projet</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="c_cpp">g++ -std=gnu++11  -c main.cpp -o main.o -Ifast-cpp-csv-parser
g++ -std=gnu++11  -o rdcpp.exe main.o  -lpthread</pre></div></div><br><h2 class="Title7 GTitle2" id="CSV-Lire-un-fichier-CVS-sous-Fast-C---CSV-Parser"><a class="Link9" href="#CSV">Lire un fichier CVS sous Fast C++ CSV Parser</a></h2><br><h3 class="Title8 GTitle3">main.cpp</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="c_cpp">//===============================================
# include "csv.h"
//===============================================
int main(int argc, char** argv) {
    io::CSVReader&lt;3&gt; in("ram.csv");
    in.read_header(io::ignore_extra_column, "vendor", "size", "speed");
    std::string vendor; int size; double speed;
    while(in.read_row(vendor, size, speed)) {
        printf("%-10s , %d , %.2f\n", vendor.c_str(), size, speed);
    }
}
//===============================================</pre></div></div><br><h3 class="Title8 GTitle3">ram.csv</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="c_cpp">vendor,size,speed
PEUGEOT,100,10.10
RENAULT,200,20.20
CITROEN,300,30.30
MERCEDES,400,40.40
BMW,500,50.50
AUDI,600,60.60</pre></div></div><br><h3 class="Title8 GTitle3">Résultat</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="c_cpp">PEUGEOT    , 100 , 10.10
RENAULT    , 200 , 20.20
CITROEN    , 300 , 30.30
MERCEDES   , 400 , 40.40
BMW        , 500 , 50.50
AUDI       , 600 , 60.60</pre></div></div><br></div></div></div></div><br><div class="Content2 GTitle1"><div class="MainBlock2"><div class="Content"><h1 class="Title2 Center" id="FTP"><a class="Link3" href="#">FTP</a></h1><div class="Body3"><br><b>File Transfer Protocol</b> (protocole de transfert de fichier), ou FTP, est un protocole de communication destiné au partage de fichiers sur un réseau TCP/IP. Il permet, depuis un ordinateur, de copier des fichiers vers un autre ordinateur du réseau, ou encore de supprimer ou de modifier des fichiers sur cet ordinateur. Ce mécanisme de copie est souvent utilisé pour alimenter un site web hébergé chez un tiers. La variante de FTP protégée par les protocoles SSL ou TLS (SSL étant le prédécesseur de TLS) s'appelle FTPS. FTP obéit à un modèle client-serveur, c'est-à-dire qu'une des deux parties, le client, envoie des requêtes auxquelles réagit l'autre, appelé serveur. En pratique, le serveur est un ordinateur sur lequel fonctionne un logiciel lui-même appelé serveur FTP, qui rend publique une arborescence de fichiers similaire à un système de fichiers UNIX. Pour accéder à un serveur FTP, on utilise un logiciel client FTP (possédant une interface graphique ou en ligne de commande). <br><br><div class="Content0 GSummary2"><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#FTP-Installer-l-environnement-fineFTP-Server-sous-Ubutnu">Installer l'environnement fineFTP Server sous Ubutnu</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#FTP-Compiler-un-projet-sous-fineFTP-Server">Compiler un projet sous fineFTP Server</a></div><div class="Item4"><i class="Icon10 fa fa-book"></i><a class="Link4" href="#FTP-Creer-un-serveur-FTP-sous-fineFTP-Server">Créer un serveur FTP sous fineFTP Server</a></div></div><br><h2 class="Title7 GTitle2" id="FTP-Installer-l-environnement-fineFTP-Server-sous-Ubutnu"><a class="Link9" href="#FTP">Installer l'environnement fineFTP Server sous Ubutnu</a></h2><br><b>FineFTP </b>est une bibliothèque de serveur FTP minimale pour les versions Windows et Unix. Le projet est basé sur CMake et ne dépend que d'asio, qui est intégré en tant que sous-module git. Aucun boost n'est nécessaire. Vous pouvez facilement intégrer cette bibliothèque dans votre propre projet afin de créer un serveur FTP intégré. <br><br><h3 class="Title8 GTitle3">Fonctionnalités</h3><br>$\checkmark$ Mode FTP passif (le seul mode dont vous avez besoin de nos jours)<br>$\checkmark$ Répertorier les répertoires<br>$\checkmark$ Chargement et téléchargement de fichiers<br>$\checkmark$ Création et suppression de fichiers et de répertoires<br>$\checkmark$ Authentification de l'utilisateur (et utilisateur anonyme sans authentification)<br>$\checkmark$ Chemin d'accès local individuel pour chaque utilisateur<br>$\checkmark$ Contrôle d'accès par utilisateur<br><br><h3 class="Title8 GTitle3">Télécharger fineFTP Server</h3><br><a class="Link7 GLink1" style="color:lime;" target="_blank" href="https://github.com/continental/fineftp-server">https://github.com/continental/fineftp-server</a><br><br><h3 class="Title8 GTitle3">Télécharger Asio</h3><br><a class="Link7 GLink1" style="color:lime;" target="_blank" href="https://github.com/chriskohlhoff/asio">https://github.com/chriskohlhoff/asio</a><br><br><h2 class="Title7 GTitle2" id="FTP-Compiler-un-projet-sous-fineFTP-Server"><a class="Link9" href="#FTP">Compiler un projet sous fineFTP Server</a></h2><br><h3 class="Title8 GTitle3">Compiler le projet</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="c_cpp">g++ -std=gnu++14  -c main.cpp -o main.o \
-Ifineftp-server/include \
-Ifineftp-server/src \
-Iasio/include

g++ -std=gnu++14  -c fineftp-server/src/filesystem.cpp -o filesystem.o \
-Ifineftp-server/include \
-Ifineftp-server/src \
-Iasio/include

g++ -std=gnu++14  -c fineftp-server/src/ftp_session.cpp -o ftp_session.o \
-Ifineftp-server/include \
-Ifineftp-server/src \
-Iasio/include

g++ -std=gnu++14  -c fineftp-server/src/server.cpp -o server.o \
-Ifineftp-server/include \
-Ifineftp-server/src \
-Iasio/include

g++ -std=gnu++14  -c fineftp-server/src/server_impl.cpp -o server_impl.o \
-Ifineftp-server/include \
-Ifineftp-server/src \
-Iasio/include

g++ -std=gnu++14  -c fineftp-server/src/user_database.cpp -o user_database.o \
-Ifineftp-server/include \
-Ifineftp-server/src \
-Iasio/include

g++ -std=gnu++14  -o rdcpp.exe  main.o \
filesystem.o ftp_session.o server.o server_impl.o user_database.o \
-lpthread</pre></div></div><br><h2 class="Title7 GTitle2" id="FTP-Creer-un-serveur-FTP-sous-fineFTP-Server"><a class="Link9" href="#FTP">Créer un serveur FTP sous fineFTP Server</a></h2><br><h3 class="Title8 GTitle3">main.cpp</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="c_cpp">//===============================================
#include &lt;fineftp/server.h&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;string&gt;
//===============================================
int main(int argc, char** argv) {
#ifdef WIN32
	std::string local_root =  "C:\\";
#else
	std::string local_root =  "/";
#endif

	fineftp::FtpServer server(2121);
	server.addUserAnonymous(local_root, fineftp::Permission::All);
	server.addUser("MyUser", "MyPassword", local_root, fineftp::Permission::ReadOnly);
	server.addUser("Uploader", "123456", local_root, fineftp::Permission::DirList | fineftp::Permission::DirCreate | fineftp::Permission::FileWrite | fineftp::Permission::FileAppend);
	server.start(4);
    
	while(1) {
		std::this_thread::sleep_for(std::chrono::milliseconds(100));
	}

	return 0;
}
//===============================================</pre></div></div><br><h3 class="Title8 GTitle3">Résultat</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="c_cpp">Successfully added anonymous user.
Successfully added user "MyUser".
Successfully added user "Uploader".
FTP Server created.
Listening at address 0.0.0.0 on port 2121:</pre></div></div><br></div></div></div></div><br><div class="Content2 GTitle1"><div class="MainBlock2"><div class="Content"><h1 class="Title2 Center" id="Eclipse"><a class="Link3" href="#">Eclipse</a></h1><div class="Body3"><br><b>Eclipse </b>est un environnement de développement intégré (IDE) utilisé en programmation informatique . Il contient un espace de travail de base et un système de plug-in extensible pour personnaliser l'environnement. Eclipse est écrit principalement en Java et son utilisation principale est le développement d'applications Java, mais il peut également être utilisé pour développer des applications dans d'autres langages de programmation via des plug-ins, notamment Ada , ABAP , C , C++ , C# , Clojure , COBOL , D , Erlang, Fortran , Groovy , Haskell , JavaScript , Julia , Lasso , Lua , NATURAL , Perl , PHP , Prolog , Python , R , Ruby (y compris le framework Ruby on Rails ), Rust , Scala et Scheme . Il peut également être utilisé pour développer des documents avec LaTeX (via un plug-in TeXlipse) et des packages pour le logiciel Mathematica. Les environnements de développement incluent les outils de développement Java (JDT) Eclipse pour Java et Scala, Eclipse CDT pour C/C++ et Eclipse PDT pour PHP, entre autres.<br><br><div class="Content0 GSummary2"><div class="Row26">Summary 2</div></div><br><h2 class="Title7 GTitle2" id="Eclipse-Environnement-de-travail"><a class="Link9" href="#Eclipse">Environnement de travail</a></h2><br><h3 class="Title8 GTitle3">Configurer l'environnement de travail</h3><br>Désactiver la vérification orthographique<br><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="c_cpp">ECLIPSE -&gt; Window -&gt; Preferences
Filter -&gt; spelling
General -&gt; Editors -&gt; Text Editors -&gt; Spelling
Spelling -&gt; Cocher -&gt; Enable spell checking
Apply and Close</pre></div></div><br>Définir l'encodage des fichiers<br><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="c_cpp">ECLIPSE -&gt; Window -&gt; Preferences
Filter -&gt; encoding
General -&gt; Workspace
Text file encoding -&gt; Other -&gt; ISO-8859-1
Apply and Close</pre></div></div><br>Désactiver le raccourci (Build All)<br><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="c_cpp">ECLIPSE -&gt; Window -&gt; Preferences
Filter -&gt; keys
General -&gt; Editors -&gt; Keys
Filer -&gt; build
Command -&gt; Build All -&gt; Selectionner
Unbind Command
Apply and Close</pre></div></div><br>Modifier le raccourci (Save All)<br><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="c_cpp">ECLIPSE -&gt; Window -&gt; Preferences
Filter -&gt; keys
General -&gt; Editors -&gt; Keys
Filer -&gt; save
Command -&gt; Save All -&gt; Selectionner
Binding -&gt; Ctrl + B
When -&gt; In Windows
Apply and Close</pre></div></div><br><h2 class="Title7 GTitle2" id="Eclipse-Recherche"><a class="Link9" href="#Eclipse">Recherche</a></h2><br><h3 class="Title8 GTitle3">Rechercher un texte</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="c_cpp">Clic droit sur le texte à rechercher
Search Text -&gt; Workspace</pre></div></div><br><h3 class="Title8 GTitle3">Rechercher un texte (par sélection)</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="c_cpp">Sélectionner le texte à rechercher
Clic droit sur le texte à rechercher
Search Text -&gt; Workspace</pre></div></div><br><h3 class="Title8 GTitle3">Rechercher un texte (par édition)</h3><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="c_cpp">ECLIPSE -&gt; Search -&gt; Search (Ctrl + H)
Containing text -&gt; MY_SEARCH_TEXT
File name pattern -&gt; *
Scope -&gt; Workspace
Search</pre></div></div><br><h3 class="Title8 GTitle3">Rechercher les références d'une variable</h3><br>La recherche par référence d'une variable permet de déterminer tous les endroits où la variable est appelée.<br><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="c_cpp">Clic droit sur la variable à rechercher
References -&gt; Workspace</pre></div></div><br><div class="Img3 GImage"><img src="/Tutoriels/Resources/ToolBox/img/i_eclipse_references_variable.png" alt="/Tutoriels/Resources/ToolBox/img/i_eclipse_references_variable.png"></div><br><h3 class="Title8 GTitle3">Rechercher les références d'une fonction</h3><br>La recherche par référence d'une fonction permet de déterminer tous les endroits où la fonction est appelée.<br><br><div class="GCode1"><div class="Code2"><pre class="AceCode" data-state="off" data-mode="c_cpp">Clic droit sur la fonction à rechercher
References -&gt; Workspace</pre></div></div><br><div class="Img3 GImage"><img src="/Tutoriels/Resources/ToolBox/img/i_eclipse_references_function.png" alt="/Tutoriels/Resources/ToolBox/img/i_eclipse_references_function.png"></div><br></div></div></div></div><br>